<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://luminqiang.github.io/</id>
    <title>卢敏强的博客</title>
    <updated>2020-04-26T14:25:40.965Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://luminqiang.github.io/"/>
    <link rel="self" href="https://luminqiang.github.io/atom.xml"/>
    <subtitle>Start With Why</subtitle>
    <logo>https://luminqiang.github.io/images/avatar.png</logo>
    <icon>https://luminqiang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 卢敏强的博客</rights>
    <entry>
        <title type="html"><![CDATA[关于C#中实现单例模式]]></title>
        <id>https://luminqiang.github.io/Uf8irdE0o/</id>
        <link href="https://luminqiang.github.io/Uf8irdE0o/">
        </link>
        <updated>2020-04-26T14:25:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ihostedservice">IHostedService</h2>
<p>该接口中有两个方法：</p>
<p>StartAsync：当应用程序主机准备启动服务时触发</p>
<p>StopAsync：当应用程序主机准备停止服务时触发</p>
<pre><code>//
// 摘要:
//     /// Defines methods for objects that are managed by the host. ///
public interface IHostedService
{
    //
    // 摘要:
    //     /// Triggered when the application host is ready to start the service. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the start process has been aborted.
    Task StartAsync(CancellationToken cancellationToken);

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the shutdown process should no longer be graceful.
    Task StopAsync(CancellationToken cancellationToken);
}
</code></pre>
<h2 id="ihostapplicationlifetime">IHostApplicationLifetime</h2>
<p>该接口中包含三个属性：Host程序的启动、正在停止、已停止，一个方法StopApplication，该方法用于主动停止程序。</p>
<pre><code>//
// 摘要:
//     /// Allows consumers to be notified of application lifetime events. ///
public interface IHostApplicationLifetime
{
    //
    // 摘要:
    //     /// Triggered when the application host has fully started. ///
    CancellationToken ApplicationStarted
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopped
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopping
    {
        get;
    }

    //
    // 摘要:
    //     /// Requests termination of the current application. ///
    void StopApplication();
}
</code></pre>
<p>这里实现<strong>IHostedService</strong>接口，然后使用<strong>IHostApplicationLifetime</strong>（该接口由框架自动实现注入），在<strong>IHostedService</strong>的<strong>StartAsync</strong>方法中注册<strong>IHostApplicationLifetime</strong>中的三个程序运行事件，可以做一些自定义的操作，我这里只是记录了日志。</p>
<pre><code>internal class LifetimeEventsHostedService : IHostedService
{
    private readonly string appCode = ConfigurationManager.GetAppSetting(&quot;AppCode&quot;);
    private readonly string appName = ConfigurationManager.GetAppSetting(&quot;AppName&quot;);
    private readonly IHostApplicationLifetime _appLifetime;

    public LifetimeEventsHostedService(IHostApplicationLifetime appLifetime)
    {
        _appLifetime = appLifetime;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _appLifetime.ApplicationStarted.Register(OnStarted);
        _appLifetime.ApplicationStopping.Register(OnStopping);
        _appLifetime.ApplicationStopped.Register(OnStopped);

        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    private void OnStarted()
    {
        var interNetworkV6 = System.Net.Sockets.AddressFamily.InterNetworkV6;
        var interNetwork = System.Net.Sockets.AddressFamily.InterNetwork;
        var ipList = System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces()
          .Select(p =&gt; p.GetIPProperties())
          .SelectMany(p =&gt; p.UnicastAddresses)
          .Where(p =&gt; (p.Address.AddressFamily == interNetwork || p.Address.AddressFamily == interNetworkV6) &amp;&amp; !System.Net.IPAddress.IsLoopback(p.Address)).ToList();

        Console.WriteLine($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
        Logger.Info($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
    }

    private void OnStopping()
    {
        Console.WriteLine($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }

    private void OnStopped()
    {
        Console.WriteLine($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }
}
</code></pre>
<p><strong>最后在服务中注入</strong></p>
<pre><code>.ConfigureServices(a =&gt;
{
    a.AddSingleton&lt;IHostedService, LifetimeEventsHostedService&gt;();
});
</code></pre>
<p><strong>也可以不使用IHostedService进行承载，直接使用IHostApplicationLifetime进行注册</strong></p>
<pre><code>internal static class RegisterLifetimeEvents
    {
        private static readonly string appCode = ConfigurationManager.GetAppSetting(&quot;AppCode&quot;);
        private static readonly string appName = ConfigurationManager.GetAppSetting(&quot;AppName&quot;);
        private static readonly string iPV4Address;
        private static readonly string iPV6Address;

        static RegisterLifetimeEvents()
        {
            var interNetworkV6 = AddressFamily.InterNetworkV6;
            var interNetwork = AddressFamily.InterNetwork;
            var ipList = NetworkInterface.GetAllNetworkInterfaces()
                .Select(p =&gt; p.GetIPProperties())
                .SelectMany(p =&gt; p.UnicastAddresses)
                .Where(p =&gt; (p.Address.AddressFamily == interNetwork || p.Address.AddressFamily == interNetworkV6) &amp;&amp; !System.Net.IPAddress.IsLoopback(p.Address)).ToList();

            iPV4Address = ipList[1]?.Address.ToString();
            iPV6Address = ipList[0]?.Address.ToString();
        }

        /// &lt;summary&gt;
        /// 注册应用程序生命周期事件
        /// &lt;/summary&gt;
        public static void RegisterApplicationLifetimeEvents(this IHost host)
        {
            var hostApplicationLifetime = host.Services.GetService&lt;IHostApplicationLifetime&gt;();
            hostApplicationLifetime.ApplicationStarted.Register(OnStarted);
            hostApplicationLifetime.ApplicationStopping.Register(OnStopping);
            hostApplicationLifetime.ApplicationStopped.Register(OnStopped);
        }

        private static void OnStarted()
        {
            Console.WriteLine($&quot;OnStarted has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
            Logger.Info($&quot;OnStarted has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
        }

        private static void OnStopping()
        {
            Console.WriteLine($&quot;OnStopping has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
            Logger.Info($&quot;OnStopping has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
        }

        private static void OnStopped()
        {
            Console.WriteLine($&quot;OnStopped has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
            Logger.Info($&quot;OnStopped has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
        }
    }
</code></pre>
<p>在Main函数中注册一下即可</p>
<pre><code>public static void Main(string[] args)
{
    var host = CreateHostBuilder(args).Build();
    host.RegisterApplicationLifetimeEvents();
    host.Run();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.NET Core 3.1 下Rest API 与 GRPC 性能测试比较]]></title>
        <id>https://luminqiang.github.io/Ces3IZPF5/</id>
        <link href="https://luminqiang.github.io/Ces3IZPF5/">
        </link>
        <updated>2020-04-14T12:39:57.000Z</updated>
        <content type="html"><![CDATA[<p>首先看看GRPC的定义：</p>
<p><strong>gRPC 是一种与语言无关的高性能远程过程调用 (RPC) 框架。</strong></p>
<p>gRPC 的主要优点是：</p>
<ol>
<li>现代高性能轻量级 RPC 框架。</li>
<li>协定优先 API 开发，默认使用协议缓冲区，允许与语言无关的实现。</li>
<li>可用于多种语言的工具，以生成强类型服务器和客户端。</li>
<li>支持客户端、服务器和双向流式处理调用。</li>
<li>使用 Protobuf 二进制序列化减少对网络的使用。</li>
</ol>
<p>这些优点使 gRPC 适用于：</p>
<ol>
<li>效率至关重要的轻量级微服务。</li>
<li>需要多种语言用于开发的 Polyglot 系统。</li>
<li>需要处理流式处理请求或响应的点对点实时服务。</li>
</ol>
<p>GRPC远程过程调用的最大优点就是高性能，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。</p>
<p>测试项目GitHub地址</p>
<pre><code>https://github.com/luminqiang/RESTvsGRPC
</code></pre>
<p>先运行API项目：</p>
<pre><code>dotnet run -p RestAPI.csproj -c Release
</code></pre>
<p>再运行GRPC项目：</p>
<pre><code>dotnet run -p GrpcAPI.csproj -c Release
</code></pre>
<p>最后运行基准测试项目：</p>
<pre><code>dotnet run -p RESTvsGRPC.csproj -c Release
</code></pre>
<p>等待测试结束后，测试结果如下：</p>
<pre><code>BenchmarkDotNet=v0.12.1, OS=Windows 10.0.18362.720 (1903/May2019Update/19H1)
Intel Core i5-9600K CPU 3.70GHz (Coffee Lake), 1 CPU, 6 logical and 6 physical cores
.NET Core SDK=3.1.201
  [Host]     : .NET Core 3.1.3 (CoreCLR 4.700.20.11803, CoreFX 4.700.20.12001), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 3.1.3 (CoreCLR 4.700.20.11803, CoreFX 4.700.20.12001), X64 RyuJIT
</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>IterationCount</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>RestGetSmallPayloadAsync</td>
<td>100</td>
<td style="text-align:right">9.244 ms</td>
<td style="text-align:right">0.0597 ms</td>
<td style="text-align:right">0.0558 ms</td>
</tr>
<tr>
<td>RestGetLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">741.352 ms</td>
<td style="text-align:right">3.9088 ms</td>
<td style="text-align:right">3.6563 ms</td>
</tr>
<tr>
<td>RestPostLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">835.936 ms</td>
<td style="text-align:right">4.9780 ms</td>
<td style="text-align:right">4.4129 ms</td>
</tr>
<tr>
<td>GrpcGetSmallPayloadAsync</td>
<td>100</td>
<td style="text-align:right">12.143 ms</td>
<td style="text-align:right">0.0586 ms</td>
<td style="text-align:right">0.0548 ms</td>
</tr>
<tr>
<td>GrpcStreamLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">800.875 ms</td>
<td style="text-align:right">6.4187 ms</td>
<td style="text-align:right">6.0041 ms</td>
</tr>
<tr>
<td>GrpcGetLargePayloadAsListAsync</td>
<td>100</td>
<td style="text-align:right">130.948 ms</td>
<td style="text-align:right">1.2500 ms</td>
<td style="text-align:right">1.1692 ms</td>
</tr>
<tr>
<td>GrpcPostLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">131.427 ms</td>
<td style="text-align:right">2.6249 ms</td>
<td style="text-align:right">4.4572 ms</td>
</tr>
<tr>
<td>RestGetSmallPayloadAsync</td>
<td>200</td>
<td style="text-align:right">18.368 ms</td>
<td style="text-align:right">0.1172 ms</td>
<td style="text-align:right">0.1096 ms</td>
</tr>
<tr>
<td>RestGetLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">1,509.909 ms</td>
<td style="text-align:right">4.7070 ms</td>
<td style="text-align:right">4.4029 ms</td>
</tr>
<tr>
<td>RestPostLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">1,676.551 ms</td>
<td style="text-align:right">6.6714 ms</td>
<td style="text-align:right">5.5710 ms</td>
</tr>
<tr>
<td>GrpcGetSmallPayloadAsync</td>
<td>200</td>
<td style="text-align:right">24.336 ms</td>
<td style="text-align:right">0.1501 ms</td>
<td style="text-align:right">0.1172 ms</td>
</tr>
<tr>
<td>GrpcStreamLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">1,598.346 ms</td>
<td style="text-align:right">6.5488 ms</td>
<td style="text-align:right">5.4685 ms</td>
</tr>
<tr>
<td>GrpcGetLargePayloadAsListAsync</td>
<td>200</td>
<td style="text-align:right">263.885 ms</td>
<td style="text-align:right">2.1572 ms</td>
<td style="text-align:right">2.0178 ms</td>
</tr>
<tr>
<td>GrpcPostLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">259.290 ms</td>
<td style="text-align:right">3.4813 ms</td>
<td style="text-align:right">3.0861 ms</td>
</tr>
</tbody>
</table>
<ul>
<li>当接口返回的数据量较小时，REST 的性能要比gRPC要好，当数据量变大之后gRPC的性能优势就比较明显了。</li>
<li>.NET Core 3的 json 进行了大量的优化， 在处理消息有效负载中的小数据时会产生巨大的差异，但是实际上，对于大数据有效负载，差异就不复存在了。</li>
<li>总体来说 gRPC在这一领域仍然是赢家，在业务案例中使用哪种协议的适当策略，通常在与外部世界的外部通信（例如外部服务集成，与前端的通信）中使用REST通信，内部服务之间通信采用gRPC。</li>
</ul>
<p><strong>因此在大数据量下，同时希望保持较高性能时，应考虑使用RPC进行通信，因为通过protobuf我们可以将数据压缩编码转化为二进制格式，通常传递的数据量要小得多，而且通过http2我们可以实现异步的请求，从而大大提高了通信效率。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.NET Core 3.0 ReadyToRun编译]]></title>
        <id>https://luminqiang.github.io/I1-q0wkHh/</id>
        <link href="https://luminqiang.github.io/I1-q0wkHh/">
        </link>
        <updated>2020-04-14T12:39:26.000Z</updated>
        <content type="html"><![CDATA[<p><strong>先来总结：ReadyToRun是一种通过适当增加程序包大小，来达到更快启动速度和运行内存占用的编译方式，在 .NET Core3.0后可用。</strong></p>
<p>.NET Core 3.0 Preview6，更新了能够加速程序加载速度的ReadyToRun（R2R）格式，以及可以缩减应用程序大小的组译连结（Assembly Linking）工具IL linker。</p>
<p>.NET Core 3.0让开发者可以把 .NET Core用程序编译成为R2R格式，以缩短启动的时间，微软提到，R2R是一种AOT（Ahead-Of-Time）编译的形式，其二进制文件能够减少JIT在加载应用程序需要的工作量，藉以提高加载的效能。</p>
<h3 id="为什么r2r-格式更快">为什么R2R 格式更快？</h3>
<p>由于R2R二进制文件包含了类似JIT所产生的原生码，因此能够减少JIT的工作给予执行缓冲空间，不过也因为R2R包含了一些中介语言程序代码，虽然因此产生的程序包相对来说也比较大，是一个启动效能与包大小的取舍。</p>
<p><strong>微软给出了实验数据：</strong></p>
<ul>
<li>只包含中介语言的应用程序，档案大小为150MB，内存使用量为69.1MB，而启动时间为1.9秒</li>
<li></li>
<li>使用ReadyToRun格式的相同应用程序，虽然档案略大为156MB，但是内存使用量只有55.7MB，而且启动速度只要1.3秒。</li>
</ul>
<h3 id="关于使用限制">关于使用限制：</h3>
<p>不过目前R2R仍有许多限制，R2R现在仅支持自包含（Self-contained）应用程序，在之后的预览版才会开始支持与框架相依的应用程序。.NET Core 3.0 SDK可以设定排除特定应用程序，以免被编译成为R2R，微软提到，部分应用程序不需要优化效能，不编译成R2R反而比较省空间。</p>
<p>.NET Core 3.0开始支持R2R，但R2R并不向后支持，因此较旧的.NET Core版本无法使用，另外，开发者只能编译函式库成R2R，以作为应用程序的一部分，目前还不能作为NuGet套件交付，微软表示，这项功能要依用户回馈决定是否要支持。</p>
<ul>
<li>R2R现在也不支持跨平台编译，在Windows x64环境只能编译Windows ARM32、ARM64以及x86映象檔，而在Linux x64只能编译Linux ARM32和ARM64映像档。除了R2R的更新，微软提到，.NET Core 3.0还提供了一个特别组译连结工具IL linker，可以透过分析中介语言并删减用不到的组译语言，确保自包含应用程序仅包含实际需要的程序代码，而这能够显著的降低某些应用程序的大小，微软提到，通常小型控制台应用程序可以减少最多，因为这些工具使用较小的框架子集，可以修剪的幅度比较大。微软的实验数据显示，对于最基本helloworld应用程序，可以从原本的68MB减少到大约28MB。</li>
<li>而使用映像或是相关动态功能的应用程序或框架，组译连结工具的修剪工作通常会失败，因为IL linker不认识这类动态行为，并且无法决定在Runtime的时候需要使用的帧类型。IL linker与ReadToRun编译程序可以用在同一个应用程序，微软表示，正常情况是IL linker会让应用程序变小，但是ReadyToRun编译程序又为让应用程序变大，但是效能会大幅提升，开发者可以在各种配置中进行测试，了解这些工具选项产生的影响。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C# 根据身份证号计算是否成年]]></title>
        <id>https://luminqiang.github.io/nym_-OBjN/</id>
        <link href="https://luminqiang.github.io/nym_-OBjN/">
        </link>
        <updated>2020-04-11T04:10:40.000Z</updated>
        <content type="html"><![CDATA[<pre><code>
public static int IsAdult(string input)
{
    if (!string.IsNullOrEmpty(input) &amp;&amp; !string.IsNullOrWhiteSpace(input))
    {
        if (input.Length != 15 &amp;&amp; input.Length != 18)
        {
            return 0;
        }

        string birthday;
        if (input.Length == 18)
        {
            birthday = input.Substring(6, 4) + &quot;-&quot; + input.Substring(10, 2) + &quot;-&quot; + input.Substring(12, 2);
        }
        else
        {
            birthday = &quot;19&quot; + input.Substring(6, 2) + &quot;-&quot; + input.Substring(8, 2) + &quot;-&quot; + input.Substring(10, 2);
        }

        DateTime birthDate = DateTime.Parse(birthday);
        DateTime nowDateTime = DateTime.Now;
        int age = nowDateTime.Year - birthDate.Year;
        if (nowDateTime.Month &lt; birthDate.Month || (nowDateTime.Month == birthDate.Month &amp;&amp; nowDateTime.Day &lt; birthDate.Day))
        {
            age--;
        }

        return 18 &lt;= age ? 1 : 2;
    }
    else
    {
        return 0;
    }
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx配置Https证书]]></title>
        <id>https://luminqiang.github.io/G2HIIUMHo/</id>
        <link href="https://luminqiang.github.io/G2HIIUMHo/">
        </link>
        <updated>2020-04-11T02:33:33.000Z</updated>
        <content type="html"><![CDATA[<pre><code>server {
    listen       80;
	server_name  luminqiang.com;
	location / {
		root   /usr/share/nginx/html;
		index  index.html index.htm;
	}
}
server {
	
    listen                    443 ssl;			#SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。
    server_name               luminqiang.com;    #将localhost修改为您证书绑定的域名，例如：www.example.com。
    ssl_certificate           /etc/nginx/cert/www.luminqiang.com.pem;
    ssl_certificate_key       /etc/nginx/cert/www.luminqiang.com.key;
    ssl_ciphers               ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件
    ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;    #使用该协议进行配置
    ssl_prefer_server_ciphers on;
    ssl_session_timeout       5m;

    location ^~/api/{
        proxy_pass http://47.99.87.3:5000;
    }
    location / {
        root   /usr/share/nginx/html;
		index  index.html index.htm;
    }
}
</code></pre>
<p>docker run -d --name nginx -p 80:80 -p 443:443 -v /usr/local/nginx/sources/home:/usr/share/nginx/html -v /usr/local/nginx/cert:/etc/nginx/cert -v /usr/local/nginx/config/default.conf:/etc/nginx/conf.d/default.conf nginx</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.NET Core 3.0 配置允许所有域名跨域]]></title>
        <id>https://luminqiang.github.io/i_Va9uR2B/</id>
        <link href="https://luminqiang.github.io/i_Va9uR2B/">
        </link>
        <updated>2020-04-09T14:03:57.000Z</updated>
        <content type="html"><![CDATA[<p>测试配置可行</p>
<pre><code>public void ConfigureServices(IServiceCollection services)
{
    services.AddCors();
}
</code></pre>
<p>SetIsOriginAllowed方法用于判断某个域名是否在允许跨域的名单中，这里不判断直接返回True</p>
<pre><code>public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)
{
    app.UseCors(options =&gt; options.SetIsOriginAllowed(x =&gt; _ = true).AllowAnyMethod().AllowAnyHeader().AllowCredentials());
}
</code></pre>
<p><strong>SetIsOriginAllowed方法注释</strong></p>
<pre><code>//
// 摘要:
//     /// Sets the specified isOriginAllowed for the underlying policy. ///
//
// 参数:
//   isOriginAllowed:
//     The function used by the policy to evaluate if an origin is allowed.
//
// 返回结果:
//     The current policy builder.
public CorsPolicyBuilder SetIsOriginAllowed(Func&lt;string, bool&gt; isOriginAllowed)
{
    throw null;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://luminqiang.github.io//post-images/1586441071443.jfif" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.NET Core 3.0 使用 IHostApplicationLifetime 处理应用启动和停止事件]]></title>
        <id>https://luminqiang.github.io/0HNFPxdKG/</id>
        <link href="https://luminqiang.github.io/0HNFPxdKG/">
        </link>
        <updated>2020-04-09T13:23:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ihostedservice">IHostedService</h2>
<p>该接口中有两个方法：</p>
<p>StartAsync：当应用程序主机准备启动服务时触发</p>
<p>StopAsync：当应用程序主机准备停止服务时触发</p>
<pre><code>//
// 摘要:
//     /// Defines methods for objects that are managed by the host. ///
public interface IHostedService
{
    //
    // 摘要:
    //     /// Triggered when the application host is ready to start the service. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the start process has been aborted.
    Task StartAsync(CancellationToken cancellationToken);

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the shutdown process should no longer be graceful.
    Task StopAsync(CancellationToken cancellationToken);
}
</code></pre>
<h2 id="ihostapplicationlifetime">IHostApplicationLifetime</h2>
<p>该接口中包含三个属性：Host程序的启动、正在停止、已停止，一个方法StopApplication，该方法用于主动停止程序。</p>
<pre><code>//
// 摘要:
//     /// Allows consumers to be notified of application lifetime events. ///
public interface IHostApplicationLifetime
{
    //
    // 摘要:
    //     /// Triggered when the application host has fully started. ///
    CancellationToken ApplicationStarted
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopped
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopping
    {
        get;
    }

    //
    // 摘要:
    //     /// Requests termination of the current application. ///
    void StopApplication();
}
</code></pre>
<p>这里实现<strong>IHostedService</strong>接口，然后使用<strong>IHostApplicationLifetime</strong>（该接口由框架自动实现注入），在<strong>IHostedService</strong>的<strong>StartAsync</strong>方法中注册<strong>IHostApplicationLifetime</strong>中的三个程序运行事件，可以做一些自定义的操作，我这里只是记录了日志。</p>
<pre><code>internal class LifetimeEventsHostedService : IHostedService
{
    private readonly string appCode = ConfigurationManager.GetAppSetting(&quot;AppCode&quot;);
    private readonly string appName = ConfigurationManager.GetAppSetting(&quot;AppName&quot;);
    private readonly IHostApplicationLifetime _appLifetime;

    public LifetimeEventsHostedService(IHostApplicationLifetime appLifetime)
    {
        _appLifetime = appLifetime;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _appLifetime.ApplicationStarted.Register(OnStarted);
        _appLifetime.ApplicationStopping.Register(OnStopping);
        _appLifetime.ApplicationStopped.Register(OnStopped);

        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    private void OnStarted()
    {
        var interNetworkV6 = System.Net.Sockets.AddressFamily.InterNetworkV6;
        var interNetwork = System.Net.Sockets.AddressFamily.InterNetwork;
        var ipList = System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces()
          .Select(p =&gt; p.GetIPProperties())
          .SelectMany(p =&gt; p.UnicastAddresses)
          .Where(p =&gt; (p.Address.AddressFamily == interNetwork || p.Address.AddressFamily == interNetworkV6) &amp;&amp; !System.Net.IPAddress.IsLoopback(p.Address)).ToList();

        Console.WriteLine($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
        Logger.Info($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
    }

    private void OnStopping()
    {
        Console.WriteLine($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }

    private void OnStopped()
    {
        Console.WriteLine($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }
}
</code></pre>
<p><strong>最后在服务中注入</strong></p>
<pre><code>.ConfigureServices(a =&gt;
{
    a.AddSingleton&lt;IHostedService, LifetimeEventsHostedService&gt;();
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理17（数据通路）]]></title>
        <id>https://luminqiang.github.io/rhctu-ULk/</id>
        <link href="https://luminqiang.github.io/rhctu-ULk/">
        </link>
        <updated>2020-02-24T02:21:23.000Z</updated>
        <content type="html"><![CDATA[<p>CPU由指令加计算两部分组成，</p>
<p>指令：我们写的代码是怎么变成一条条机器能够理解的指令；</p>
<p>计算：也就是数据的二进制表现（定点数、浮点数），加法和乘法的实现，通过什么电路（半加器、全加器）。</p>
<p>只有把“指令”和“计算”这两部分功能连通起来，也就是建立数据通路，我们才能构成一个真正完整的 CPU。</p>
<p><strong>指令周期（Instruction Cycle）</strong></p>
<p>计算机每执行一条指令的过程，可以分解成这样几个步骤：</p>
<hr>
<ol>
<li>Fetch（取得指令），也就是从 PC 寄存器里找到对应的指令地址，根据指令地址从内存里把具体的指令，加载到指令寄存器中，然后把 PC 寄存器自增，好在未来执行下一条指令。</li>
</ol>
<hr>
<ol start="2">
<li>Decode（指令译码），也就是根据指令寄存器里面的指令，解析成要进行什么样的操作，是 R、I、J 中的哪一种指令，具体要操作哪些寄存器、数据或者内存地址。</li>
</ol>
<hr>
<ol start="3">
<li>Execute（执行指令），也就是实际运行对应的 R、I、J 这些特定的指令，进行算术逻辑操作、数据传输或者直接的地址跳转。</li>
</ol>
<hr>
<ol start="4">
<li>重复进行 1～3 的步骤。</li>
</ol>
<hr>
<p>这样的步骤，就构成了永不停歇的“Fetch - Decode - Execute”的循环，我们把这个循环称之为指令周期（Instruction Cycle）。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/18/a7/1840bead02cfbe5d8f70e2f0a7b962a7.jpg" alt="image" loading="lazy"></figure>
<p>1.指令存放于存储器中（PC寄存器、指令寄存器）</p>
<p>2.控制器从寄存器中取出指令，并对指令进行解码</p>
<p>3.运算器（算术逻辑单元ALU）负责指令的执行，如果是简单的无条件跳转，不需要计算的，则直接由运算器解决</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/bd/67/bde3548a4789ba49cab74c8c1ab02a67.jpeg" alt="image" loading="lazy"></figure>
<p>除了指令周期（Instruction Cycle），CPU中还有其他周期：</p>
<ol>
<li>机器周期（Machine Cycle）</li>
<li>CPU周期（CPU Cycle）：CPU 内部的操作速度很快，但是访问内存的速度却要慢很多。每一条指令都需要从内存里面加载而来，所以我们一般把从内存里面读取一条指令的最短时间，称为 CPU 周期。</li>
<li>时钟周期（Clock Cycle）：就是CPU的主频如3.5GHZ，一个 CPU 周期，通常会由几个时钟周期累积起来。一个 CPU 周期的时间，就是这几个 Clock Cycle 的总和。</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/1a/48/1a7d2d6cf7cb78a8f48775268f452e48.jpeg" alt="image" loading="lazy"></figure>
<p>在一个指令周期中，取出指令，至少需要一个 CPU 周期，执行指令，也至少需要一个CPU周期，复杂的指令就需要更多的CPU周期（&gt;=2）,一个指令周期包含多个CPU周期，一个CPU周期包含多个时钟周期。</p>
<p><strong>建立数据通路</strong></p>
<p>数据通路就是我们的处理器单元。它通常由两类原件组成：</p>
<ol>
<li>操作元件，也叫组合逻辑元件（Combinational Element），其实就是我们的 ALU。在前面讲 ALU 的过程中可以看到，它们的功能就是在特定的输入下，根据下面的组合电路的逻辑，生成特定的输出。</li>
<li>存储元件，也有叫状态元件（State Element）的。比如我们在计算过程中需要用到的寄存器，无论是通用寄存器还是状态寄存器，其实都是存储元件。</li>
</ol>
<p>通过数据总线的方式，把它们连接起来，就可以完成数据的存储、处理和传输了，这就是所谓的建立数据通路了。</p>
<p>此时还需要控制器作为算术逻辑单元和寄存器的中间桥梁，它的逻辑就没那么复杂了。我们可以把它看成只是机械地重复“Fetch - Decode - Execute“循环中的前两个步骤，然后把最后一个步骤，通过控制器产生的控制信号，交给 ALU 去处理。</p>
<p>但实际上控制器的电路特别复杂：</p>
<p>一方面，所有 CPU 支持的指令，都会在控制器里面，被解析成不同的输出信号。我们之前说过，现在的 Intel CPU 支持 2000 个以上的指令。这意味着，控制器输出的控制信号，至少有 2000 种不同的组合。</p>
<p>运算器里的 ALU 和各种组合逻辑电路，可以认为是一个固定功能的电路。控制器“翻译”出来的，就是不同的控制信号。这些控制信号，告诉 ALU 去做不同的计算。可以说正是控制器的存在，让我们可以“编程”来实现功能，能让我们的“存储程序型计算机”名副其实。</p>
<figure data-type="image" tabindex="4"><img src="https://static001.geekbang.org/resource/image/46/6f/46087a894b4ac182fab83ac3786cad6f.jpeg" alt="image" loading="lazy"></figure>
<pre><code>指令译码器将输入的机器码，解析成不同的操作码和操作数，然后传输给 ALU 进行计算
</code></pre>
<p><strong>CPU 所需要的硬件电路</strong></p>
<ol>
<li>
<p>自然是我们之前已经讲解过的 ALU 了，它实际就是一个没有状态的，根据输入计算输出结果的第一个电路。</p>
</li>
<li>
<p>我们需要有一个能够进行状态读写的电路元件，也就是我们的寄存器。我们需要有一个电路，能够存储到上一次的计算结果。这个计算结果并不一定要立刻拿到电路的下游去使用，但是可以在需要的时候拿出来用。常见的能够进行状态读写的电路，就有锁存器（Latch），以及我们后面要讲的 D 触发器（Data/Delay Flip-flop）的电路。</p>
</li>
<li>
<p>我们需要有一个“自动”的电路，按照固定的周期，不停地实现 PC 寄存器自增，自动地去执行“Fetch - Decode - Execute“的步骤。我们的程序执行，并不是靠人去拨动开关来执行指令的。我们希望有一个“自动”的电路，不停地去一条条执行指令。</p>
<p>我们看似写了各种复杂的高级程序进行各种函数调用、条件跳转。其实只是修改 PC 寄存器里面的地址。PC 寄存器里面的地址一修改，计算机就可以加载一条指令新指令，往下运行。实际上，PC 寄存器还有一个名字，就叫作程序计数器。顾名思义，就是随着时间变化，不断去数数。数的数字变大了，就去执行一条新指令。所以，我们需要的就是一个自动数数的电路。</p>
</li>
<li>
<p>我们需要有一个“译码”的电路。无论是对于指令进行 decode，还是对于拿到的内存地址去获取对应的数据或者指令，我们都需要通过一个电路找到对应的数据。这个对应的自然就是“译码器”的电路了。</p>
</li>
</ol>
<p>需要的 4 种基本电路，它们分别是，ALU 这样的组合逻辑电路、用来存储数据的锁存器和 D 触发器电路、用来实现 PC 寄存器的计数器电路，以及用来解码和寻址的译码器电路。</p>
<p>虽然 CPU 已经是由几十亿个晶体管组成的及其复杂的电路，但是它仍然是由这样一个个基本功能的电路组成的。只要搞清楚这些电路的运作原理，你自然也就弄明白了 CPU 的工作原理。</p>
<p><strong>为什么 CPU 还会有满载运行和 Idle 闲置的状态呢？</strong></p>
<p>CPU在空闲状态就会停止执行，具体来说就是切断时钟信号，CPU的主频就会瞬间降低为0，功耗也会瞬间降低为0。由于这个空闲状态是十分短暂的，所以在任务管理器里面也只会看到CPU频率下降，不会看到降低为0。当CPU从空闲状态中恢复时，就会接通时钟信号，这样CPU频率就会上升。所以会在任务管理器里面看到CPU的频率起伏变化。</p>
<p>同时，程序计数器一直在变化，意味着满载，如果持续不变就是idle。CPU密集型任务需要CPU大量计算的任务，这个时候CPU负载就很高，IO密集型任务，CPU一直在等待IO，就会有idle。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器的同源策略]]></title>
        <id>https://luminqiang.github.io/liu-lan-qi-de-tong-yuan-ce-lue/</id>
        <link href="https://luminqiang.github.io/liu-lan-qi-de-tong-yuan-ce-lue/">
        </link>
        <updated>2020-02-21T01:14:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="什么是同源策略">什么是同源策略？</h3>
<p>浏览器最基本的安全规范——同源策略(Same-Origin Policy)。所谓同源是指<strong>域名</strong>、<strong>协议</strong>、<strong>端口</strong>相同。不同源的<strong>浏览器脚本</strong>(javascript、ActionScript、canvas)在没明确授权的情况下，不能读写对方的资源。</p>
<h3 id="为什么需要同源策略">为什么需要同源策略？</h3>
<p>同源策略规定了浏览器脚本互操作web数据的基本原则，若没有这一基本原则，那么：</p>
<ol>
<li>某域下DOM元素被另一方任意操作、篡改，导致页面显示失控</li>
<li>某域下的cookie等与该域相关的数据片段可以随意读取，导致与该域密切相关的浏览器cookie片段可能失真</li>
<li>恶意网站能随意执行Ajax脚本偷取隐私数据，导致该域下核心业务数据被抓取。</li>
</ol>
<h3 id="怎么应对同源策略">怎么应对同源策略？</h3>
<p>默认的同源策略 限制了脚本互操作其他域的能力，大棒一挥， 关闭了A站脚本正常访问B站数据的需求，有以下变通方法：</p>
<ol>
<li>实现CORS (Cross-Origin Resource Sharing)</li>
<li>使用JSONP (JSON Padding)</li>
<li>建立一个本地代理服务器，这样先同源访问，由代理服务器转发请求</li>
</ol>
<p><strong>方案1:CORS是w3C对于跨域请求推出的明确方案；方案2、3均是Hack行为。</strong></p>
<h3 id="关于cors跨域请求方案">关于CORS跨域请求方案</h3>
<p>W3C推出的跨域请求方案：<strong>让web服务器明确授权非同源页面脚本来访问自身，以Response特定标头Access-Control-*******-体现</strong>；目前现代浏览器均认可并支持这些标头。<br>
<strong>CORS特定HTTP标头，为浏览器提供了授权脚本跨域访问其他域名页面数据的通道</strong>。</p>
<p>所以CORS是处理跨域请求的常见方案，在Net Core中通常在Startup中配置跨域请求。</p>
<p>常规的带Cookie Ajax跨域请求：</p>
<pre><code>const invocation = new XMLHttpRequest();
const url = 'http://bar.other/resources/credentialed-content/';
function callOtherDomain(){
  if(invocation) {
    invocation.open('GET', url, true);
    invocation.withCredentials = true;   // Ajax请求默认不会发送凭据， 这里设定在Ajax跨域请求中发送凭据
    invocation.onreadystatechange = handler;
    invocation.send(); 
  }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://mmbiz.qpic.cn/mmbiz_png/Nf8EFKZQ5kO2TLsQ3NM1NLAZ5oHGKxvEKQgfL1WyPo11b6hIdeg4yUqP4LWRJNMSK7XFyyXB3jJce7lZ2eNXLg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image" loading="lazy"></figure>
<h3 id="cors规范">CORS规范：</h3>
<ol>
<li>浏览器发起CORS或POST请求，浏览器会自动携带Origin标头（指示请求来自于哪个站点）</li>
<li>Web服务器实现跨域访问授权逻辑。 授权结果在Response中以Access-Control--******* 标头体现。</li>
<li>浏览器会遵守Access-Control--*******-- 标头值所施加的跨域限制。</li>
</ol>
<p>最常见的Access-Control-Allow-Origin标头包含  * / Origin /null三种响应值；当请求是携带凭据的跨域请求，不可囫囵吞枣地指定为*通配符，而必须指定特定Origin</p>
<pre><code>GET /resources/access-control-with-credentials/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Referer: http://foo.example/examples/credential.html
Origin: http://foo.example
Cookie: pageAccess=2


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:34:52 GMT
Server: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2
X-Powered-By: PHP/5.2.6
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Credentials: true
Cache-Control: no-cache
Pragma: no-cache
Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 106
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain


[text/plain payload]
</code></pre>
<p>以上表示了一个常见的携带cookie跨域Ajax Get请求，其中Access-Control-Allow-Credentials: true指示浏览器可以将跨域请求的Response结果暴露给页面。</p>
<h3 id="cors中的请求预检preflight">CORS中的请求预检Preflight</h3>
<p>对于非简单Ajax请求（通常是GET以外的HTTP方法，或者某些MIME类型的POST用法），CORS规范要求发起&quot;预检&quot;请求。</p>
<p>注：不过，预检请求不需要你手动发起，浏览器会自动使用OPTIONS请求方法从服务器请求支持的方法，然后在服务器“批准”时，使用实际的HTTP请求方法发送实际请求。</p>
<figure data-type="image" tabindex="2"><img src="https://mmbiz.qpic.cn/mmbiz_png/Nf8EFKZQ5kO2TLsQ3NM1NLAZ5oHGKxvEFCgLeQjvFNhoRmYrnF61OKHHwsMDJDnlicx5vQ9WY6xfVUM6BWZtOHA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image" loading="lazy"></figure>
<p>下面使用POST动作发起Ajax跨域请求，同时自定义request header：X-PINGOTHER，该请求触发浏览器预检行为</p>
<pre><code>
const invocation = new XMLHttpRequest();
const url = 'http://bar.other/resources/post-here/';
const body = '&lt;?xml version=&quot;1.0&quot;?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;';
    
function callOtherDomain(){
  if(invocation)
    {
      invocation.open('POST', url, true);
      invocation.setRequestHeader('X-PINGOTHER', 'pingpong');
      invocation.setRequestHeader('Content-Type', 'application/xml');
      invocation.onreadystatechange = handler;
      invocation.send(body); 
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://mmbiz.qpic.cn/mmbiz_png/Nf8EFKZQ5kO2TLsQ3NM1NLAZ5oHGKxvEiac7pdBDgRp336gAQ096hfTpnvicH2zjlEyibhG1S0Kmmy4zGGfTmcRVA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image" loading="lazy"></figure>
<h3 id="总结">总结</h3>
<ol>
<li>浏览器同源策略限制对象是浏览器脚本；</li>
<li>存在跨域请求的场景，某些方案是Hack行为；</li>
<li>W3C推出的CORS 是标准的跨域请求方案，思路是在服务端Response标头体现 授权, 浏览器遵守该授权标头。</li>
<li>对于非简单的脚本跨域请求，浏览器会自动发起 Option请求预检， 大部分时候无需关注</li>
<li>提供curl 工具帮助高效、优雅调试CORS。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理学习笔记（程序的编译、链接、装载）]]></title>
        <id>https://luminqiang.github.io/ji-suan-ji-zu-cheng-yuan-li-xue-xi-bi-ji-cheng-xu-de-bian-yi-lian-jie-zhuang-zai/</id>
        <link href="https://luminqiang.github.io/ji-suan-ji-zu-cheng-yuan-li-xue-xi-bi-ji-cheng-xu-de-bian-yi-lian-jie-zhuang-zai/">
        </link>
        <updated>2020-02-20T13:51:03.000Z</updated>
        <content type="html"><![CDATA[<p>首先我们都明白写好的程序通过编译之后变成了机器码由CPU执行，但是为什么相同的代码无法在同一台计算机的Linux和Windows系统下同时运行？</p>
<ul>
<li>
<h2 id="拆解程序执行">拆解程序执行</h2>
</li>
</ul>
<p>写好的 C 语言代码，可以通过编译器编译成汇编代码，然后汇编代码再通过汇编器变成 CPU 可以理解的机器码，于是 CPU 就可以执行这些机器码。这个过程是最简练的三个步骤，但具体是怎么变成一个可执行程序的呢？</p>
<p><strong>“C 语言代码 - 汇编代码 - 机器码”</strong> 这个过程，在我们的计算机上进行的时候是由两部分组成的。</p>
<p>第一部分:由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成。在这三个阶段完成之后，我们就生成了一个可执行文件。</p>
<p>第二部分:通过装载器（Loader）把可执行文件装载（Load）到内存中。CPU 从内存中读取指令和数据，来开始真正执行程序。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/99/a7/997341ed0fa9018561c7120c19cfa2a7.jpg" alt="iamge" loading="lazy"></figure>
<ul>
<li>
<h2 id="elf-格式和链接理解链接过程">ELF 格式和链接：理解链接过程</h2>
</li>
</ul>
<p>程序最终是通过装载器变成指令和数据的，所以其实我们生成的可执行代码也并不仅仅是一条条的指令。</p>
<p>Linux 下，可执行文件和目标文件所使用的都是一种叫ELF（Execuatable and Linkable File Format）的文件格式，中文名字叫可执行与可链接文件格式，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/27/b3/276a740d0eabf5f4be905fe7326d9fb3.jpg" alt="image" loading="lazy"></figure>
<p>ELF 文件格式把各种信息，分成一个一个的 Section 保存起来。ELF 有一个基本的文件头（File Header），用来表示这个文件的基本属性，比如是否是可执行文件，对应的 CPU、操作系统等等。除了这些基本属性之外，大部分程序还有这么一些 Section：</p>
<ol>
<li>
<p>首先是.text Section，也叫作代码段或者指令段（Code Section），用来保存程序的代码和指令；</p>
</li>
<li>
<p>接着是.data Section，也叫作数据段（Data Section），用来保存程序里面设置好的初始化数据信息；</p>
</li>
<li>
<p>然后就是.rel.text Secion，叫作重定位表（Relocation Table）。重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如上面的 link_example.o 里面，我们在 main 函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；</p>
</li>
<li>
<p>最后是.symtab Section，叫作符号表（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。</p>
</li>
</ol>
<p>链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。</p>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/f6/12/f62da9b29aa53218f8907851df27f912.jpeg" alt="image" loading="lazy"></figure>
<p>在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。</p>
<p>为什么同样一个程序，在 Linux 下可以执行而在 Windows 下不能执行了。其中一个非常重要的原因就是，两个操作系统下可执行文件的格式不一样。</p>
<p>Linux 下是 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作PE（Portable Executable Format）的文件格式。Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。</p>
<p>如果我们有一个可以能够解析 PE 格式的装载器，我们就有可能在 Linux 下运行 Windows 程序了。这样的程序真的存在吗？没错，Linux 下著名的开源项目 Wine，就是通过兼容 PE 格式的装载器，使得我们能直接在 Linux 下运行 Windows 程序的。而现在微软的 Windows 里面也提供了 WSL，也就是 Windows Subsystem for Linux，可以解析和加载 ELF 格式的文件。</p>
<p>我们去写可以用的程序，也不仅仅是把所有代码放在一个文件里来编译执行，而是可以拆分成不同的函数库，最后通过一个静态链接的机制，使得不同的文件之间既有分工，又能通过静态链接来“合作”，变成一个可执行的程序。</p>
<p>对于 ELF 格式的文件，为了能够实现这样一个静态链接的机制，里面不只是简单罗列了程序所需要执行的指令，还会包括链接所需要的重定位表和符号表。</p>
]]></content>
    </entry>
</feed>