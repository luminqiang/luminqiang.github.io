<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://luminqiang.github.io/</id>
    <title>卢敏强的博客</title>
    <updated>2019-12-25T15:05:47.274Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://luminqiang.github.io/"/>
    <link rel="self" href="https://luminqiang.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://luminqiang.github.io//images/avatar.png</logo>
    <icon>https://luminqiang.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 卢敏强的博客</rights>
    <entry>
        <title type="html"><![CDATA[HTTP的实体数据]]></title>
        <id>https://luminqiang.github.io//post/http-de-shi-ti-shu-ju</id>
        <link href="https://luminqiang.github.io//post/http-de-shi-ti-shu-ju">
        </link>
        <updated>2019-12-25T15:02:52.000Z</updated>
        <content type="html"><![CDATA[<p><strong>数据类型与编码</strong><br>
在 TCP/IP 协议栈里，传输数据基本上都是“header+body”的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。</p>
<p>而 HTTP 协议则不同，它是应用层的协议，数据到达之后工作只能说是完成了一半，还必须要告诉上层应用这是什么数据才行，否则上层应用就会“不知所措”。</p>
<p>你可以设想一下，假如 HTTP 没有告知数据类型的功能，服务器把“一大坨”数据发给了浏览器，浏览器看到的是一个“黑盒子”，这时候该怎么办呢？</p>
<p>当然，它可以“猜”。因为很多数据都是有固定格式的，所以通过检查数据的前几个字节也许就能知道这是个 GIF 图片、或者是个 MP3 音乐文件，但这种方式无疑十分低效，而且有很大几率会检查不出来文件类型。</p>
<p>幸运的是，早在 HTTP 协议诞生之前就已经有了针对这种问题的解决方案，不过它是用在电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，方案的名字叫做“多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 MIME。</p>
<p>MIME 是一个很大的标准规范，但 HTTP 只“顺手牵羊”取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的“MIME type”。</p>
<p>MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串，巧得很，刚好也符合了 HTTP 明文的特点，所以能够很容易地纳入 HTTP 头字段里。</p>
<p>这里简单列举一下在 HTTP 里经常遇到的几个类别：</p>
<p>text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。<br>
image：即图像文件，有 image/gif、image/jpeg、image/png 等。<br>
audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。<br>
application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。<br>
但仅有 MIME type 还不够，因为 HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续“猜”，还需要有一个“Encoding type”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。</p>
<p>比起 MIME type 来说，Encoding type 就少了很多，常用的只有下面三种：</p>
<p>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；<br>
deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；<br>
br：一种专门为 HTTP 优化的新压缩算法（Brotli）。</p>
]]></content>
    </entry>
</feed>