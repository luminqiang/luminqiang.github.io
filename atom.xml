<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://luminqiang.github.io/</id>
    <title>卢敏强的博客</title>
    <updated>2020-04-09T13:24:18.644Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://luminqiang.github.io/"/>
    <link rel="self" href="https://luminqiang.github.io/atom.xml"/>
    <subtitle>Start With Why</subtitle>
    <logo>https://luminqiang.github.io/images/avatar.png</logo>
    <icon>https://luminqiang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 卢敏强的博客</rights>
    <entry>
        <title type="html"><![CDATA[.NET Core 3.0 使用 IHostApplicationLifetime 处理应用启动和停止事件]]></title>
        <id>https://luminqiang.github.io/0HNFPxdKG/</id>
        <link href="https://luminqiang.github.io/0HNFPxdKG/">
        </link>
        <updated>2020-04-09T13:23:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ihostedservice">IHostedService</h2>
<p>该接口中有两个方法：</p>
<p>StartAsync：当应用程序主机准备启动服务时触发</p>
<p>StopAsync：当应用程序主机准备停止服务时触发</p>
<pre><code>//
// 摘要:
//     /// Defines methods for objects that are managed by the host. ///
public interface IHostedService
{
    //
    // 摘要:
    //     /// Triggered when the application host is ready to start the service. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the start process has been aborted.
    Task StartAsync(CancellationToken cancellationToken);

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the shutdown process should no longer be graceful.
    Task StopAsync(CancellationToken cancellationToken);
}
</code></pre>
<h2 id="ihostapplicationlifetime">IHostApplicationLifetime</h2>
<p>该接口中包含三个属性：Host程序的启动、正在停止、已停止，一个方法StopApplication，该方法用于主动停止程序。</p>
<pre><code>//
// 摘要:
//     /// Allows consumers to be notified of application lifetime events. ///
public interface IHostApplicationLifetime
{
    //
    // 摘要:
    //     /// Triggered when the application host has fully started. ///
    CancellationToken ApplicationStarted
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopped
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopping
    {
        get;
    }

    //
    // 摘要:
    //     /// Requests termination of the current application. ///
    void StopApplication();
}
</code></pre>
<p>这里实现<strong>IHostedService</strong>接口，然后使用<strong>IHostApplicationLifetime</strong>（该接口由框架自动实现注入），在<strong>IHostedService</strong>的<strong>StartAsync</strong>方法中注册<strong>IHostApplicationLifetime</strong>中的三个程序运行事件，可以做一些自定义的操作，我这里只是记录了日志。</p>
<pre><code>internal class LifetimeEventsHostedService : IHostedService
{
    private readonly string appCode = ConfigurationManager.GetAppSetting(&quot;AppCode&quot;);
    private readonly string appName = ConfigurationManager.GetAppSetting(&quot;AppName&quot;);
    private readonly IHostApplicationLifetime _appLifetime;

    public LifetimeEventsHostedService(IHostApplicationLifetime appLifetime)
    {
        _appLifetime = appLifetime;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _appLifetime.ApplicationStarted.Register(OnStarted);
        _appLifetime.ApplicationStopping.Register(OnStopping);
        _appLifetime.ApplicationStopped.Register(OnStopped);

        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    private void OnStarted()
    {
        var interNetworkV6 = System.Net.Sockets.AddressFamily.InterNetworkV6;
        var interNetwork = System.Net.Sockets.AddressFamily.InterNetwork;
        var ipList = System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces()
          .Select(p =&gt; p.GetIPProperties())
          .SelectMany(p =&gt; p.UnicastAddresses)
          .Where(p =&gt; (p.Address.AddressFamily == interNetwork || p.Address.AddressFamily == interNetworkV6) &amp;&amp; !System.Net.IPAddress.IsLoopback(p.Address)).ToList();

        Console.WriteLine($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
        Logger.Info($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
    }

    private void OnStopping()
    {
        Console.WriteLine($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }

    private void OnStopped()
    {
        Console.WriteLine($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }
}
</code></pre>
<p><strong>最后在服务中注入</strong></p>
<pre><code>.ConfigureServices(a =&gt;
{
    a.AddSingleton&lt;IHostedService, LifetimeEventsHostedService&gt;();
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理17（数据通路）]]></title>
        <id>https://luminqiang.github.io/rhctu-ULk/</id>
        <link href="https://luminqiang.github.io/rhctu-ULk/">
        </link>
        <updated>2020-02-24T02:21:23.000Z</updated>
        <content type="html"><![CDATA[<p>CPU由指令加计算两部分组成，</p>
<p>指令：我们写的代码是怎么变成一条条机器能够理解的指令；</p>
<p>计算：也就是数据的二进制表现（定点数、浮点数），加法和乘法的实现，通过什么电路（半加器、全加器）。</p>
<p>只有把“指令”和“计算”这两部分功能连通起来，也就是建立数据通路，我们才能构成一个真正完整的 CPU。</p>
<p><strong>指令周期（Instruction Cycle）</strong></p>
<p>计算机每执行一条指令的过程，可以分解成这样几个步骤：</p>
<hr>
<ol>
<li>Fetch（取得指令），也就是从 PC 寄存器里找到对应的指令地址，根据指令地址从内存里把具体的指令，加载到指令寄存器中，然后把 PC 寄存器自增，好在未来执行下一条指令。</li>
</ol>
<hr>
<ol start="2">
<li>Decode（指令译码），也就是根据指令寄存器里面的指令，解析成要进行什么样的操作，是 R、I、J 中的哪一种指令，具体要操作哪些寄存器、数据或者内存地址。</li>
</ol>
<hr>
<ol start="3">
<li>Execute（执行指令），也就是实际运行对应的 R、I、J 这些特定的指令，进行算术逻辑操作、数据传输或者直接的地址跳转。</li>
</ol>
<hr>
<ol start="4">
<li>重复进行 1～3 的步骤。</li>
</ol>
<hr>
<p>这样的步骤，就构成了永不停歇的“Fetch - Decode - Execute”的循环，我们把这个循环称之为指令周期（Instruction Cycle）。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/18/a7/1840bead02cfbe5d8f70e2f0a7b962a7.jpg" alt="image" loading="lazy"></figure>
<p>1.指令存放于存储器中（PC寄存器、指令寄存器）</p>
<p>2.控制器从寄存器中取出指令，并对指令进行解码</p>
<p>3.运算器（算术逻辑单元ALU）负责指令的执行，如果是简单的无条件跳转，不需要计算的，则直接由运算器解决</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/bd/67/bde3548a4789ba49cab74c8c1ab02a67.jpeg" alt="image" loading="lazy"></figure>
<p>除了指令周期（Instruction Cycle），CPU中还有其他周期：</p>
<ol>
<li>机器周期（Machine Cycle）</li>
<li>CPU周期（CPU Cycle）：CPU 内部的操作速度很快，但是访问内存的速度却要慢很多。每一条指令都需要从内存里面加载而来，所以我们一般把从内存里面读取一条指令的最短时间，称为 CPU 周期。</li>
<li>时钟周期（Clock Cycle）：就是CPU的主频如3.5GHZ，一个 CPU 周期，通常会由几个时钟周期累积起来。一个 CPU 周期的时间，就是这几个 Clock Cycle 的总和。</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/1a/48/1a7d2d6cf7cb78a8f48775268f452e48.jpeg" alt="image" loading="lazy"></figure>
<p>在一个指令周期中，取出指令，至少需要一个 CPU 周期，执行指令，也至少需要一个CPU周期，复杂的指令就需要更多的CPU周期（&gt;=2）,一个指令周期包含多个CPU周期，一个CPU周期包含多个时钟周期。</p>
<p><strong>建立数据通路</strong></p>
<p>数据通路就是我们的处理器单元。它通常由两类原件组成：</p>
<ol>
<li>操作元件，也叫组合逻辑元件（Combinational Element），其实就是我们的 ALU。在前面讲 ALU 的过程中可以看到，它们的功能就是在特定的输入下，根据下面的组合电路的逻辑，生成特定的输出。</li>
<li>存储元件，也有叫状态元件（State Element）的。比如我们在计算过程中需要用到的寄存器，无论是通用寄存器还是状态寄存器，其实都是存储元件。</li>
</ol>
<p>通过数据总线的方式，把它们连接起来，就可以完成数据的存储、处理和传输了，这就是所谓的建立数据通路了。</p>
<p>此时还需要控制器作为算术逻辑单元和寄存器的中间桥梁，它的逻辑就没那么复杂了。我们可以把它看成只是机械地重复“Fetch - Decode - Execute“循环中的前两个步骤，然后把最后一个步骤，通过控制器产生的控制信号，交给 ALU 去处理。</p>
<p>但实际上控制器的电路特别复杂：</p>
<p>一方面，所有 CPU 支持的指令，都会在控制器里面，被解析成不同的输出信号。我们之前说过，现在的 Intel CPU 支持 2000 个以上的指令。这意味着，控制器输出的控制信号，至少有 2000 种不同的组合。</p>
<p>运算器里的 ALU 和各种组合逻辑电路，可以认为是一个固定功能的电路。控制器“翻译”出来的，就是不同的控制信号。这些控制信号，告诉 ALU 去做不同的计算。可以说正是控制器的存在，让我们可以“编程”来实现功能，能让我们的“存储程序型计算机”名副其实。</p>
<figure data-type="image" tabindex="4"><img src="https://static001.geekbang.org/resource/image/46/6f/46087a894b4ac182fab83ac3786cad6f.jpeg" alt="image" loading="lazy"></figure>
<pre><code>指令译码器将输入的机器码，解析成不同的操作码和操作数，然后传输给 ALU 进行计算
</code></pre>
<p><strong>CPU 所需要的硬件电路</strong></p>
<ol>
<li>
<p>自然是我们之前已经讲解过的 ALU 了，它实际就是一个没有状态的，根据输入计算输出结果的第一个电路。</p>
</li>
<li>
<p>我们需要有一个能够进行状态读写的电路元件，也就是我们的寄存器。我们需要有一个电路，能够存储到上一次的计算结果。这个计算结果并不一定要立刻拿到电路的下游去使用，但是可以在需要的时候拿出来用。常见的能够进行状态读写的电路，就有锁存器（Latch），以及我们后面要讲的 D 触发器（Data/Delay Flip-flop）的电路。</p>
</li>
<li>
<p>我们需要有一个“自动”的电路，按照固定的周期，不停地实现 PC 寄存器自增，自动地去执行“Fetch - Decode - Execute“的步骤。我们的程序执行，并不是靠人去拨动开关来执行指令的。我们希望有一个“自动”的电路，不停地去一条条执行指令。</p>
<p>我们看似写了各种复杂的高级程序进行各种函数调用、条件跳转。其实只是修改 PC 寄存器里面的地址。PC 寄存器里面的地址一修改，计算机就可以加载一条指令新指令，往下运行。实际上，PC 寄存器还有一个名字，就叫作程序计数器。顾名思义，就是随着时间变化，不断去数数。数的数字变大了，就去执行一条新指令。所以，我们需要的就是一个自动数数的电路。</p>
</li>
<li>
<p>我们需要有一个“译码”的电路。无论是对于指令进行 decode，还是对于拿到的内存地址去获取对应的数据或者指令，我们都需要通过一个电路找到对应的数据。这个对应的自然就是“译码器”的电路了。</p>
</li>
</ol>
<p>需要的 4 种基本电路，它们分别是，ALU 这样的组合逻辑电路、用来存储数据的锁存器和 D 触发器电路、用来实现 PC 寄存器的计数器电路，以及用来解码和寻址的译码器电路。</p>
<p>虽然 CPU 已经是由几十亿个晶体管组成的及其复杂的电路，但是它仍然是由这样一个个基本功能的电路组成的。只要搞清楚这些电路的运作原理，你自然也就弄明白了 CPU 的工作原理。</p>
<p><strong>为什么 CPU 还会有满载运行和 Idle 闲置的状态呢？</strong></p>
<p>CPU在空闲状态就会停止执行，具体来说就是切断时钟信号，CPU的主频就会瞬间降低为0，功耗也会瞬间降低为0。由于这个空闲状态是十分短暂的，所以在任务管理器里面也只会看到CPU频率下降，不会看到降低为0。当CPU从空闲状态中恢复时，就会接通时钟信号，这样CPU频率就会上升。所以会在任务管理器里面看到CPU的频率起伏变化。</p>
<p>同时，程序计数器一直在变化，意味着满载，如果持续不变就是idle。CPU密集型任务需要CPU大量计算的任务，这个时候CPU负载就很高，IO密集型任务，CPU一直在等待IO，就会有idle。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器的同源策略]]></title>
        <id>https://luminqiang.github.io/liu-lan-qi-de-tong-yuan-ce-lue/</id>
        <link href="https://luminqiang.github.io/liu-lan-qi-de-tong-yuan-ce-lue/">
        </link>
        <updated>2020-02-21T01:14:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="什么是同源策略">什么是同源策略？</h3>
<p>浏览器最基本的安全规范——同源策略(Same-Origin Policy)。所谓同源是指<strong>域名</strong>、<strong>协议</strong>、<strong>端口</strong>相同。不同源的<strong>浏览器脚本</strong>(javascript、ActionScript、canvas)在没明确授权的情况下，不能读写对方的资源。</p>
<h3 id="为什么需要同源策略">为什么需要同源策略？</h3>
<p>同源策略规定了浏览器脚本互操作web数据的基本原则，若没有这一基本原则，那么：</p>
<ol>
<li>某域下DOM元素被另一方任意操作、篡改，导致页面显示失控</li>
<li>某域下的cookie等与该域相关的数据片段可以随意读取，导致与该域密切相关的浏览器cookie片段可能失真</li>
<li>恶意网站能随意执行Ajax脚本偷取隐私数据，导致该域下核心业务数据被抓取。</li>
</ol>
<h3 id="怎么应对同源策略">怎么应对同源策略？</h3>
<p>默认的同源策略 限制了脚本互操作其他域的能力，大棒一挥， 关闭了A站脚本正常访问B站数据的需求，有以下变通方法：</p>
<ol>
<li>实现CORS (Cross-Origin Resource Sharing)</li>
<li>使用JSONP (JSON Padding)</li>
<li>建立一个本地代理服务器，这样先同源访问，由代理服务器转发请求</li>
</ol>
<p><strong>方案1:CORS是w3C对于跨域请求推出的明确方案；方案2、3均是Hack行为。</strong></p>
<h3 id="关于cors跨域请求方案">关于CORS跨域请求方案</h3>
<p>W3C推出的跨域请求方案：<strong>让web服务器明确授权非同源页面脚本来访问自身，以Response特定标头Access-Control-*******-体现</strong>；目前现代浏览器均认可并支持这些标头。<br>
<strong>CORS特定HTTP标头，为浏览器提供了授权脚本跨域访问其他域名页面数据的通道</strong>。</p>
<p>所以CORS是处理跨域请求的常见方案，在Net Core中通常在Startup中配置跨域请求。</p>
<p>常规的带Cookie Ajax跨域请求：</p>
<pre><code>const invocation = new XMLHttpRequest();
const url = 'http://bar.other/resources/credentialed-content/';
function callOtherDomain(){
  if(invocation) {
    invocation.open('GET', url, true);
    invocation.withCredentials = true;   // Ajax请求默认不会发送凭据， 这里设定在Ajax跨域请求中发送凭据
    invocation.onreadystatechange = handler;
    invocation.send(); 
  }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://mmbiz.qpic.cn/mmbiz_png/Nf8EFKZQ5kO2TLsQ3NM1NLAZ5oHGKxvEKQgfL1WyPo11b6hIdeg4yUqP4LWRJNMSK7XFyyXB3jJce7lZ2eNXLg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image" loading="lazy"></figure>
<h3 id="cors规范">CORS规范：</h3>
<ol>
<li>浏览器发起CORS或POST请求，浏览器会自动携带Origin标头（指示请求来自于哪个站点）</li>
<li>Web服务器实现跨域访问授权逻辑。 授权结果在Response中以Access-Control--******* 标头体现。</li>
<li>浏览器会遵守Access-Control--*******-- 标头值所施加的跨域限制。</li>
</ol>
<p>最常见的Access-Control-Allow-Origin标头包含  * / Origin /null三种响应值；当请求是携带凭据的跨域请求，不可囫囵吞枣地指定为*通配符，而必须指定特定Origin</p>
<pre><code>GET /resources/access-control-with-credentials/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Referer: http://foo.example/examples/credential.html
Origin: http://foo.example
Cookie: pageAccess=2


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:34:52 GMT
Server: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2
X-Powered-By: PHP/5.2.6
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Credentials: true
Cache-Control: no-cache
Pragma: no-cache
Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 106
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain


[text/plain payload]
</code></pre>
<p>以上表示了一个常见的携带cookie跨域Ajax Get请求，其中Access-Control-Allow-Credentials: true指示浏览器可以将跨域请求的Response结果暴露给页面。</p>
<h3 id="cors中的请求预检preflight">CORS中的请求预检Preflight</h3>
<p>对于非简单Ajax请求（通常是GET以外的HTTP方法，或者某些MIME类型的POST用法），CORS规范要求发起&quot;预检&quot;请求。</p>
<p>注：不过，预检请求不需要你手动发起，浏览器会自动使用OPTIONS请求方法从服务器请求支持的方法，然后在服务器“批准”时，使用实际的HTTP请求方法发送实际请求。</p>
<figure data-type="image" tabindex="2"><img src="https://mmbiz.qpic.cn/mmbiz_png/Nf8EFKZQ5kO2TLsQ3NM1NLAZ5oHGKxvEFCgLeQjvFNhoRmYrnF61OKHHwsMDJDnlicx5vQ9WY6xfVUM6BWZtOHA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image" loading="lazy"></figure>
<p>下面使用POST动作发起Ajax跨域请求，同时自定义request header：X-PINGOTHER，该请求触发浏览器预检行为</p>
<pre><code>
const invocation = new XMLHttpRequest();
const url = 'http://bar.other/resources/post-here/';
const body = '&lt;?xml version=&quot;1.0&quot;?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;';
    
function callOtherDomain(){
  if(invocation)
    {
      invocation.open('POST', url, true);
      invocation.setRequestHeader('X-PINGOTHER', 'pingpong');
      invocation.setRequestHeader('Content-Type', 'application/xml');
      invocation.onreadystatechange = handler;
      invocation.send(body); 
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://mmbiz.qpic.cn/mmbiz_png/Nf8EFKZQ5kO2TLsQ3NM1NLAZ5oHGKxvEiac7pdBDgRp336gAQ096hfTpnvicH2zjlEyibhG1S0Kmmy4zGGfTmcRVA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image" loading="lazy"></figure>
<h3 id="总结">总结</h3>
<ol>
<li>浏览器同源策略限制对象是浏览器脚本；</li>
<li>存在跨域请求的场景，某些方案是Hack行为；</li>
<li>W3C推出的CORS 是标准的跨域请求方案，思路是在服务端Response标头体现 授权, 浏览器遵守该授权标头。</li>
<li>对于非简单的脚本跨域请求，浏览器会自动发起 Option请求预检， 大部分时候无需关注</li>
<li>提供curl 工具帮助高效、优雅调试CORS。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理学习笔记（程序的编译、链接、装载）]]></title>
        <id>https://luminqiang.github.io/ji-suan-ji-zu-cheng-yuan-li-xue-xi-bi-ji-cheng-xu-de-bian-yi-lian-jie-zhuang-zai/</id>
        <link href="https://luminqiang.github.io/ji-suan-ji-zu-cheng-yuan-li-xue-xi-bi-ji-cheng-xu-de-bian-yi-lian-jie-zhuang-zai/">
        </link>
        <updated>2020-02-20T13:51:03.000Z</updated>
        <content type="html"><![CDATA[<p>首先我们都明白写好的程序通过编译之后变成了机器码由CPU执行，但是为什么相同的代码无法在同一台计算机的Linux和Windows系统下同时运行？</p>
<ul>
<li>
<h2 id="拆解程序执行">拆解程序执行</h2>
</li>
</ul>
<p>写好的 C 语言代码，可以通过编译器编译成汇编代码，然后汇编代码再通过汇编器变成 CPU 可以理解的机器码，于是 CPU 就可以执行这些机器码。这个过程是最简练的三个步骤，但具体是怎么变成一个可执行程序的呢？</p>
<p><strong>“C 语言代码 - 汇编代码 - 机器码”</strong> 这个过程，在我们的计算机上进行的时候是由两部分组成的。</p>
<p>第一部分:由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成。在这三个阶段完成之后，我们就生成了一个可执行文件。</p>
<p>第二部分:通过装载器（Loader）把可执行文件装载（Load）到内存中。CPU 从内存中读取指令和数据，来开始真正执行程序。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/99/a7/997341ed0fa9018561c7120c19cfa2a7.jpg" alt="iamge" loading="lazy"></figure>
<ul>
<li>
<h2 id="elf-格式和链接理解链接过程">ELF 格式和链接：理解链接过程</h2>
</li>
</ul>
<p>程序最终是通过装载器变成指令和数据的，所以其实我们生成的可执行代码也并不仅仅是一条条的指令。</p>
<p>Linux 下，可执行文件和目标文件所使用的都是一种叫ELF（Execuatable and Linkable File Format）的文件格式，中文名字叫可执行与可链接文件格式，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/27/b3/276a740d0eabf5f4be905fe7326d9fb3.jpg" alt="image" loading="lazy"></figure>
<p>ELF 文件格式把各种信息，分成一个一个的 Section 保存起来。ELF 有一个基本的文件头（File Header），用来表示这个文件的基本属性，比如是否是可执行文件，对应的 CPU、操作系统等等。除了这些基本属性之外，大部分程序还有这么一些 Section：</p>
<ol>
<li>
<p>首先是.text Section，也叫作代码段或者指令段（Code Section），用来保存程序的代码和指令；</p>
</li>
<li>
<p>接着是.data Section，也叫作数据段（Data Section），用来保存程序里面设置好的初始化数据信息；</p>
</li>
<li>
<p>然后就是.rel.text Secion，叫作重定位表（Relocation Table）。重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如上面的 link_example.o 里面，我们在 main 函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；</p>
</li>
<li>
<p>最后是.symtab Section，叫作符号表（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。</p>
</li>
</ol>
<p>链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。</p>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/f6/12/f62da9b29aa53218f8907851df27f912.jpeg" alt="image" loading="lazy"></figure>
<p>在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。</p>
<p>为什么同样一个程序，在 Linux 下可以执行而在 Windows 下不能执行了。其中一个非常重要的原因就是，两个操作系统下可执行文件的格式不一样。</p>
<p>Linux 下是 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作PE（Portable Executable Format）的文件格式。Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。</p>
<p>如果我们有一个可以能够解析 PE 格式的装载器，我们就有可能在 Linux 下运行 Windows 程序了。这样的程序真的存在吗？没错，Linux 下著名的开源项目 Wine，就是通过兼容 PE 格式的装载器，使得我们能直接在 Linux 下运行 Windows 程序的。而现在微软的 Windows 里面也提供了 WSL，也就是 Windows Subsystem for Linux，可以解析和加载 ELF 格式的文件。</p>
<p>我们去写可以用的程序，也不仅仅是把所有代码放在一个文件里来编译执行，而是可以拆分成不同的函数库，最后通过一个静态链接的机制，使得不同的文件之间既有分工，又能通过静态链接来“合作”，变成一个可执行的程序。</p>
<p>对于 ELF 格式的文件，为了能够实现这样一个静态链接的机制，里面不只是简单罗列了程序所需要执行的指令，还会包括链接所需要的重定位表和符号表。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理学习笔记（一）]]></title>
        <id>https://luminqiang.github.io/ji-suan-ji-zu-cheng-yuan-li-xue-xi-bi-ji-yi/</id>
        <link href="https://luminqiang.github.io/ji-suan-ji-zu-cheng-yuan-li-xue-xi-bi-ji-yi/">
        </link>
        <updated>2020-02-12T00:59:29.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://luminqiang.github.io//post-images/1581469229146.jfif" alt="" loading="lazy"></figure>
<p>计算机组成原理（Computer Organization），Organization为“组织结构”的意思，计算机的组成便是很多不同的部件构成的一个组织结构，这个组织结构可以进行计算、存储、输入、输出，组合在一起可以实现各种功能。</p>
<p>冯.诺依曼体系结构中的五大基本组件：<br>
运算器、寄存器、输入、输出设备、存储器</p>
<p>计算机的两个核心指标：<br>
性能和功耗</p>
<p>CPU:Central Processing Unit(中央处理器)，由寄存器、控制器、运算器、时钟四个部分组成，每个部分由电流信号相互连通。</p>
<p>寄存器：<br>
用来暂存指令、数据等处理对象，是提供给CPU使用的“内存”，一个CPU内部会有20-100个寄存器。zhixing</p>
<p>寄存器的种类：<br>
累加寄存器：存储zhi'xing</p>
<p>控制器：<br>
负责把内存上的数据、指令等信息读入寄存器，并根据指令的执行结果来控制计算机。</p>
<p>运算器：<br>
负责运算寄存器中的数据。</p>
<p>时钟：<br>
发出CPU开始计时的时钟信号。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP学习之缓存机制]]></title>
        <id>https://luminqiang.github.io/http-xue-xi-zhi-huan-cun-ji-zhi/</id>
        <link href="https://luminqiang.github.io/http-xue-xi-zhi-huan-cun-ji-zhi/">
        </link>
        <updated>2019-12-28T02:20:57.000Z</updated>
        <content type="html"><![CDATA[<p><strong>什么是缓存？</strong><br>
缓存(Cache)是计算机领域里的重要概念，是优化系统性能的重要手段。</p>
<p><strong>为什么需要缓存？</strong><br>
链路漫长，网络时延不可控，浏览器使用http获取资源的成本比较高，把上次请求的数据进行缓存，下次请求时可直接使用缓存中的数据，避免再进行多次请求 - 应答，节约网络带宽，提高响应速度。</p>
<p><strong>缓存的基本流程？</strong><br>
1.浏览器发现缓存无数据，则从浏览器获取相应的资源<br>
2.服务器响应请求，返回资源，标记资源有效期<br>
3.浏览器对资源进行缓存，再次请求在有效期内则使用缓存</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/a1/5b/a1968821f214df4a3ae16c9b30f99a5b.png" alt="" loading="lazy"></figure>
<p><strong>服务端控制缓存？</strong></p>
<p>控制缓存通过请求/响应头中添加对应的缓存控制字段</p>
<p>响应头中添加 Cache-Control:max-age=30，意思为该资源的有效时间为30秒，max-age代表资源的生存期，时间是从浏览器响应时间开始计算，并不是指浏览器拿到响应数据的时间，因为这是服务端进行设置的，自然是站在服务端的角度。</p>
<p>max-age是缓存控制的基本属性，还有其他属性用来更精确的控制</p>
<p>1.no_store 不允许浏览器缓存，资源变化比较频繁的数据一般使用这个选项<br>
2.no_cache 并不是是指不使用缓存，而是可以使用缓存，但每次使用都必须去服务端验证缓存是否失效<br>
3.must_revaldate 缓存不过期则可以继续使用，过期后再去服务端验证，不需要每次进行验证</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/8a/b2/8a67535620ab9c7764560363f83982b2.png" alt="" loading="lazy"></figure>
<p><strong>客户端控制缓存？</strong></p>
<p>客户端控制缓存也是使用Cache-Control请求头字段，请求方和响应方都可以使用这个字段进行缓存控制，互相协商。</p>
<p>常见场景：<br>
1.F5刷新页面</p>
<p>浏览器在请求头中添加Cache-Control:max=age=0 ，希望服务端返回最新的数据</p>
<figure data-type="image" tabindex="3"><img src="https://luminqiang.github.io//post-images/1577501221957.png" alt="" loading="lazy"></figure>
<p>2.Ctrl + F5 强制刷新页面</p>
<p>浏览器在请求头中添加Cache-Control:no_cache，检查是否有最新的数据，有则返回</p>
<figure data-type="image" tabindex="4"><img src="https://luminqiang.github.io//post-images/1577501283189.png" alt="" loading="lazy"></figure>
<p>二者的效果通常是一致的</p>
<p><strong>条件请求</strong></p>
<p>浏览器用“Cache-Control”做缓存控制只能是刷新数据，但是如何去验证数据是否过期是否有效却做不到，需要通过其他方式实现。</p>
<p>1.浏览器使用两个请求<br>
第一步 先发送一个最简单的Head请求，获取资源的元信息，判断缓存的资源是否过期<br>
第二步 如果对比后资源过期，则使用Get请求获取新数据</p>
<p>但是因为需要使用两个请求才能完成验证，所以HTTP协议定义了一系列If开头的条件请求字段，专门用于检测资源是否过期，将验证工作整合在一次请求中，由服务端进行验证工作。</p>
<p>条件请求一共有 5 个头字段，我们最常用的是“if-Modified-Since”和“If-None-Match”这两个。需要第一次的响应报文预先提供“Last-modified”和“ETag”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。</p>
<p>如果资源没有变，服务器就回应一个“304 Not Modified”，表示缓存依然有效，浏览器就可以更新一下有效期，然后放心大胆地使用缓存了。</p>
<figure data-type="image" tabindex="5"><img src="https://static001.geekbang.org/resource/image/b2/37/b239d0804be630ce182e24ea9e4ab237.png" alt="" loading="lazy"></figure>
<p>Last-modified : 文件的最后修改时间</p>
<p>ETag : “实体标签”（Entity Tag）的缩写，是资源的一个唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题。</p>
<p>ETag 还有“强”“弱”之分。强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP学习笔记之连接管理]]></title>
        <id>https://luminqiang.github.io/http-xue-xi-bi-ji-zhi-lian-jie-guan-li/</id>
        <link href="https://luminqiang.github.io/http-xue-xi-bi-ji-zhi-lian-jie-guan-li/">
        </link>
        <updated>2019-12-26T13:41:58.000Z</updated>
        <content type="html"><![CDATA[<p>HTTP的性能中规中矩，不算差，并不够好，比不上RPC这种协议，但是胜在简单方便，关于http的连接，则分为短连接与长连接。</p>
<p>短连接<br>
HTTP 协议的最初版本0.9/1.0，是个非常简单的协议，通信过程也采用了简单的“请求 - 应答”方式。</p>
<p>它底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。</p>
<p>因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“<strong>短连接</strong>”（short-lived connections）。早期的 HTTP 协议也被称为是“<strong>无连接</strong>”的协议。</p>
<p><strong>短连接的缺点：</strong><br>
在 TCP 协议里，建立连接和关闭连接都是非常“昂贵”的操作。<br>
TCP 建立连接要有“三次握手”，发送 3 个数据包，需要 1 个 RTT；<br>
关闭连接是“四次挥手”，4 个数据包需要 2 个 RTT。</p>
<p><strong>什么是RTT？</strong><br>
RTT=传播时延（往返）+排队时延（路由器和交换机的）+数据处理时延（应用程序的）<br>
<img src="https://pic2.zhimg.com/v2-99e600bf39d58d7732b159325ca0caf7_r.jpg" alt="" loading="lazy"></p>
<p>而即使 HTTP最简单的一次“请求 - 响应”通常需要 4 个包，如果不算服务器内部的处理时间，最多是 2 个 RTT。这么算下来，浪费的时间就是“3÷5=60%”，有三分之二的时间被浪费掉了，传输效率低得惊人。<br>
<img src="https://static001.geekbang.org/resource/image/54/0c/54315ed9ac37fbc6547258040f00a80c.png" alt="" loading="lazy"></p>
<p><strong>长连接</strong><br>
针对短连接暴露出的缺点，HTTP 协议就提出了“长连接”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。</p>
<p>其解决思路为“成本均摊”，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个“请求 - 应答”均摊到多个“请求 - 应答”上。</p>
<p>虽然不能改善 TCP 的连接效率，但基于“分母效应”，每个“请求 - 应答”的无效时间就会降低不少，整体传输效率也就提高了。</p>
<p><strong>短连接与长连接的对比示意图</strong><br>
<img src="https://static001.geekbang.org/resource/image/57/b4/57b3d80234a1f1b8c538a376aa01d3b4.png" alt="" loading="lazy"></p>
<p>在短连接里发送了三次 HTTP“请求 - 应答”，每次都会浪费 60% 的 RTT 时间。而在长连接的情况下，同样发送三次请求，因为只在第一次时建立连接，在最后一次时关闭连接，所以浪费率就是“3÷9≈33%”，降低了差不多一半的时间损耗。显然，如果在这个长连接上发送的请求越多，分母就越大，利用率也就越高。</p>
<p><strong>连接相关的头字段</strong><br>
由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。</p>
<p>当然，我们也可以在请求头里明确地要求使用长连接机制，使用的字段是<strong>Connection</strong>，值是“<strong>keep-alive</strong>”。</p>
<p>如果服务器支持长连接，它总会在响应报文里放一个“<strong>Connection: keep-alive</strong>”字段，告诉客户端：“我是支持长连接的，接下来就用这个 TCP 一直收发数据吧”。</p>
<p><strong>长连接的缺点</strong></p>
<p>因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</p>
<p>所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到：</p>
<p>在客户端，可以在请求头里加上“Connection: close”字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</p>
<p>服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</p>
<p>1.使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</p>
<p>2.使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</p>
<p><strong>队头阻塞：</strong></p>
<p>什么是队头阻塞？<br>
因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。如果队首的请求耽误时间，队列里后的所有请求阻塞起等待。<br>
<img src="https://static001.geekbang.org/resource/image/6a/72/6a6d30a89fb085d5f1773a887aaf5572.png" alt="" loading="lazy"></p>
<p><strong>优化队头阻塞问题</strong><br>
“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解：</p>
<p>1.采用就是“<strong>并发连接</strong>”（concurrent connections），也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。</p>
<p>缺陷：如果客户端随意建立多个连接，用户数 x 并发数，将会形成巨大的连接数，服务器资源很快耗尽，最后拒绝响应。浏览器一般并发连接数为6-8。</p>
<p>2.采用“<strong>域名分片</strong>”（domain sharding）技术，还是用数量来解决质量的思路。<br>
多个域名都指向同一台服务器 www.chrono.com，这样实际长连接的数量就又上去了。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/f9/72/f93afe4b663d681b8ce63c947f478072.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>