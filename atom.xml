<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://luminqiang.github.io/</id>
    <title>卢敏强的博客</title>
    <updated>2020-09-28T13:49:00.321Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://luminqiang.github.io/"/>
    <link rel="self" href="https://luminqiang.github.io/atom.xml"/>
    <subtitle>Start With Why</subtitle>
    <logo>https://luminqiang.github.io/images/avatar.png</logo>
    <icon>https://luminqiang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 卢敏强的博客</rights>
    <entry>
        <title type="html"><![CDATA[总结一下模式匹配功能]]></title>
        <id>https://luminqiang.github.io/X9VZrVU9p/</id>
        <link href="https://luminqiang.github.io/X9VZrVU9p/">
        </link>
        <updated>2020-09-28T13:48:40.000Z</updated>
        <content type="html"><![CDATA[<p>从C#7开始推出模式匹配以来，每次C#版本升级都会对模式匹配进行升级，到最新的C#9，又更新了好几个关于模式匹配的新特性（新玩法），可见模式匹配这一特性在C#语言生态中的重要地位。模式匹配到C#9为止，目前有这么多种用法，在这里总结归纳一下，以后才能玩的更溜。</p>
<p><strong>C#7里的第一代模式匹配</strong></p>
<p>一句话：C# 7.0 通过使用 is 表达式和 switch 语句引入了类型模式和常量模式的语法。</p>
<ul>
<li><strong>is表达式的用法</strong></li>
<li>以下对引用类型和值类型进行测试，可以将成功结果分配给类型正确的<strong>新变量</strong></li>
</ul>
<pre><code>public async static Task Main()
{
    var o = new object();
    var s = new Student()
    {
        Name = &quot;luminqiang&quot;,
        Age = 25
    };

    if (o is Student student)
    {
        Console.WriteLine(student.Name + student.Age);
    }

    if (s is Student student1)
    {
        var dseds = s.Equals(student1);
        Console.WriteLine(student1.Name + student1.Age);
    }

    int number_one = 10;
    if (number_one is int number_two)
    {
        number_two += 10;
    }
}

    public class Student
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }
</code></pre>
<ul>
<li><strong>switch 匹配表达式的用法</strong></li>
<li>switch语句不再限制为常量值如数字类型和字符串，还可以使用其他自定义类型</li>
</ul>
<pre><code>case 0: 是常见的常量模式。
case IEnumerable&lt;int&gt; childSequence: 是一种类型模式。
case int n when n &gt; 0: 是具有附加 when 条件的类型模式。
case null: 是 null 模式。
default: 是常见的默认事例。
</code></pre>
<pre><code>var student = new Student
{
    Age = 25,
    Name = &quot;luminqiang&quot;
};

switch (student)
{         
    case Student s when s.Name == &quot;lumiqiang&quot;:
        Console.WriteLine(&quot;这个是学霸&quot;);
        break;
    case object o when o == null:
        Console.WriteLine(&quot;这个是谁不知道&quot;);
        break;
    default:
        throw new ArgumentException(&quot;不合法的类型&quot;);
}
</code></pre>
<p><strong>C#8里的第二代模式匹配</strong></p>
<pre><code>public enum Rainbow
{
    Red,
    Orange,
    Yellow,
    Green,
    Blue,
    Indigo,
    Violet
}
</code></pre>
<p>这里有几个语法改进：</p>
<ul>
<li>变量位于 switch 关键字之前。 不同的顺序使得在视觉上可以很轻松地区分 switch 表达式和 switch 语句。</li>
<li>将 case 和 : 元素替换为 =&gt;。 它更简洁，更直观。</li>
<li>将 default 事例替换为 _ 弃元。</li>
<li>正文是表达式，不是语句。</li>
</ul>
<pre><code>public static RGBColor FromRainbow(Rainbow colorBand) =&gt;
colorBand switch
{
    Rainbow.Red    =&gt; new RGBColor(0xFF, 0x00, 0x00),
    Rainbow.Orange =&gt; new RGBColor(0xFF, 0x7F, 0x00),
    Rainbow.Yellow =&gt; new RGBColor(0xFF, 0xFF, 0x00),
    Rainbow.Green  =&gt; new RGBColor(0x00, 0xFF, 0x00),
    Rainbow.Blue   =&gt; new RGBColor(0x00, 0x00, 0xFF),
    Rainbow.Indigo =&gt; new RGBColor(0x4B, 0x00, 0x82),
    Rainbow.Violet =&gt; new RGBColor(0x94, 0x00, 0xD3),
    _              =&gt; throw new ArgumentException(message: &quot;invalid enum value&quot;, paramName: nameof(colorBand)),
};
</code></pre>
<p>下面是经典的常规写法，我目前还是更喜欢这种经典的写法，反而我解决的这种经典写法更直观，哈哈，虽然代码多了几行，新写法可能需要时间来适应一下</p>
<pre><code>public static RGBColor FromRainbowClassic(Rainbow colorBand)
{
    switch (colorBand)
    {
        case Rainbow.Red:
            return new RGBColor(0xFF, 0x00, 0x00);
        case Rainbow.Orange:
            return new RGBColor(0xFF, 0x7F, 0x00);
        case Rainbow.Yellow:
            return new RGBColor(0xFF, 0xFF, 0x00);
        case Rainbow.Green:
            return new RGBColor(0x00, 0xFF, 0x00);
        case Rainbow.Blue:
            return new RGBColor(0x00, 0x00, 0xFF);
        case Rainbow.Indigo:
            return new RGBColor(0x4B, 0x00, 0x82);
        case Rainbow.Violet:
            return new RGBColor(0x94, 0x00, 0xD3);
        default:
            throw new ArgumentException(message: &quot;invalid enum value&quot;, paramName: nameof(colorBand));
    };
}
</code></pre>
<ul>
<li><strong>属性模式：可以匹配所检查的对象的属性</strong></li>
</ul>
<pre><code>public static decimal ComputeSalesTax(Address location, decimal salePrice) =&gt;
    location switch
    {
        { State: &quot;WA&quot; } =&gt; salePrice * 0.06M,
        { State: &quot;MN&quot; } =&gt; salePrice * 0.075M,
        { State: &quot;MI&quot; } =&gt; salePrice * 0.05M,
        // other cases removed for brevity...
        _ =&gt; 0M
    };
</code></pre>
<ul>
<li><strong>元组模式：使用元组模式，可根据表示为元组的多个值进行切换</strong></li>
</ul>
<pre><code>public static string RockPaperScissors(string first, string second)
    =&gt; (first, second) switch
    {
        (&quot;rock&quot;, &quot;paper&quot;) =&gt; &quot;rock is covered by paper. Paper wins.&quot;,
        (&quot;rock&quot;, &quot;scissors&quot;) =&gt; &quot;rock breaks scissors. Rock wins.&quot;,
        (&quot;paper&quot;, &quot;rock&quot;) =&gt; &quot;paper covers rock. Paper wins.&quot;,
        (&quot;paper&quot;, &quot;scissors&quot;) =&gt; &quot;paper is cut by scissors. Scissors wins.&quot;,
        (&quot;scissors&quot;, &quot;rock&quot;) =&gt; &quot;scissors is broken by rock. Rock wins.&quot;,
        (&quot;scissors&quot;, &quot;paper&quot;) =&gt; &quot;scissors cuts paper. Scissors wins.&quot;,
        (_, _) =&gt; &quot;tie&quot;
    };
</code></pre>
<ul>
<li>
<p><strong>位置模式：某些类型包含 Deconstruct 方法，该方法将其属性解构为离散变量</strong></p>
</li>
<li>
<p>这个用法我是有点懵的...</p>
</li>
</ul>
<pre><code>public class Point
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y) =&gt; (X, Y) = (x, y);

    public void Deconstruct(out int x, out int y) =&gt;
        (x, y) = (X, Y);
}
</code></pre>
<pre><code>public enum Quadrant
{
    Unknown,
    Origin,
    One,
    Two,
    Three,
    Four,
    OnBorder
}
</code></pre>
<pre><code>static Quadrant GetQuadrant(Point point) =&gt; point switch
{
    (0, 0) =&gt; Quadrant.Origin,
    var (x, y) when x &gt; 0 &amp;&amp; y &gt; 0 =&gt; Quadrant.One,
    var (x, y) when x &lt; 0 &amp;&amp; y &gt; 0 =&gt; Quadrant.Two,
    var (x, y) when x &lt; 0 &amp;&amp; y &lt; 0 =&gt; Quadrant.Three,
    var (x, y) when x &gt; 0 &amp;&amp; y &lt; 0 =&gt; Quadrant.Four,
    var (_, _) =&gt; Quadrant.OnBorder,
    _ =&gt; Quadrant.Unknown
};
</code></pre>
<p><strong>C#9里的第三代模式匹配</strong></p>
<p>主要是进行了一些改进</p>
<ul>
<li>类型模式要求在变量是一种类型时匹配</li>
<li>带圆括号的模式强制或强调模式组合的优先级</li>
<li>联合 and 模式要求两个模式都匹配</li>
<li>析取 or 模式要求任一模式匹配</li>
<li>求反 not 模式要求模式不匹配</li>
<li>关系模式要求输入小于、大于、小于等于或大于等于给定常数。</li>
</ul>
<pre><code>public static bool IsLetter(this char c) =&gt;
    c is &gt;= 'a' and &lt;= 'z' or &gt;= 'A' and &lt;= 'Z';
</code></pre>
<p>使用可选的括号来明确 and 的优先级高于 or：</p>
<pre><code>public static bool IsLetterOrSeparator(this char c) =&gt;
    c is (&gt;= 'a' and &lt;= 'z') or (&gt;= 'A' and &lt;= 'Z') or '.' or ',';
</code></pre>
<p>最常见的用途之一是用于 NULL 检查的新语法：</p>
<pre><code>if (e is not null)
{
    // ...
}
</code></pre>
<p>总结：目前来说，并不是所有的模式匹配语法都用的上，但是以后可以使用模式匹配改进的地方还是值得一试的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于.Net Core3.0下因客户端主动取消请求导致的Request.Body异常]]></title>
        <id>https://luminqiang.github.io/xeXII_Rdv/</id>
        <link href="https://luminqiang.github.io/xeXII_Rdv/">
        </link>
        <updated>2020-09-26T06:34:37.000Z</updated>
        <content type="html"><![CDATA[<p>最近上线的一个日志上报接口出现了这个异常信息</p>
<p>异常内容如下：</p>
<pre><code>   at Microsoft.AspNetCore.Server.Kestrel.Core.BadHttpRequestException.Throw(RequestRejectionReason reason)
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ContentLengthMessageBody.&lt;ReadAsyncInternal&gt;d__9.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)
   at System.Threading.Tasks.ValueTask`1.get_Result()
   at System.Runtime.CompilerServices.ValueTaskAwaiter`1.GetResult()
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream.&lt;ReadAsyncInternal&gt;d__30.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.IO.StreamReader.&lt;ReadBufferAsync&gt;d__67.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.IO.StreamReader.&lt;ReadToEndAsyncInternal&gt;d__61.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at CT.TcyLianYunBall.WebApi.Controllers.LogSdkController.Report() 
</code></pre>
<pre><code>{
    &quot;StatusCode&quot;:400,
    &quot;StackTrace&quot;:&quot;   at Microsoft.AspNetCore.Server.Kestrel.Core.BadHttpRequestException.Throw(RequestRejectionReason reason)
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ContentLengthMessageBody.ReadAsyncInternal(CancellationToken cancellationToken)
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream.ReadAsyncInternal(Memory`1 buffer, CancellationToken cancellationToken)
   at Microsoft.AspNetCore.WebUtilities.FileBufferingReadStream.ReadAsync(Byte[] buffer, Int32 offset, Int32 count, CancellationToken cancellationToken)
   at Microsoft.AspNetCore.WebUtilities.StreamHelperExtensions.DrainAsync(Stream stream, ArrayPool`1 bytePool, Nullable`1 limit, CancellationToken cancellationToken)
   at Microsoft.AspNetCore.Mvc.Formatters.NewtonsoftJsonInputFormatter.ReadRequestBodyAsync(InputFormatterContext context, Encoding encoding)
   at Microsoft.AspNetCore.Mvc.ModelBinding.Binders.BodyModelBinder.BindModelAsync(ModelBindingContext bindingContext)
   at Microsoft.AspNetCore.Mvc.ModelBinding.ParameterBinder.BindModelAsync(ActionContext actionContext, IModelBinder modelBinder, IValueProvider valueProvider, ParameterDescriptor parameter, ModelMetadata metadata, Object value)
   at Microsoft.AspNetCore.Mvc.Controllers.ControllerBinderDelegateProvider.&lt;&gt;c__DisplayClass0_0.&lt;g__Bind|0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.g__Awaited|13_0(ControllerActionInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.g__Awaited|25_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)&quot;,
    &quot;Message&quot;:&quot;Unexpected end of request content.&quot;,
    &quot;Data&quot;:{

    },
    &quot;InnerException&quot;:null,
    &quot;HelpLink&quot;:null,
    &quot;Source&quot;:&quot;Microsoft.AspNetCore.Server.Kestrel.Core&quot;,
    &quot;HResult&quot;:-2146232800
}
</code></pre>
<p>出现该错误的原因是因为客户端主动取消了请求，比如客户端的某个请求还在处理，客户端的第二个请求过来，然后客户端刷新页面或其他方式的操作取消了这个请求，就会导致服务端开始处理第二个请求的时候会RequestBody为空，因为在模型绑定之前就已经取消了请求。</p>
<p><strong>本地调试的复现步骤：</strong></p>
<ul>
<li>在请求处理过程的某处设置断点</li>
<li>在PostMan或浏览器上先发送A请求，命中断点，不继续往下处理，让请求阻塞</li>
<li>继续发放B请求，这时请求阻塞中，然后点击取消请求</li>
<li>释放断点继续处理，结果是A请求正常处理结束，B请求处理时抛出异常</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li>可选择在全局异常过滤器中不处理该异常，不打印错误日志</li>
</ul>
<p>参考博客</p>
<pre><code>https://q.cnblogs.com/q/117223/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker中安装Mysql]]></title>
        <id>https://luminqiang.github.io/szrT1kASg/</id>
        <link href="https://luminqiang.github.io/szrT1kASg/">
        </link>
        <updated>2020-09-17T23:52:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>准备搭建Mysql主从同步，原来是在linux直接安装的，感觉不是很方便，这次准备使用挂载的方式安装，前提是Docker已经安装好了</strong></p>
<ul>
<li><strong>搜索Mysql</strong></li>
</ul>
<pre><code> docker search mysql
</code></pre>
<p>搜索结果如下：</p>
<pre><code>NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
mysql                             MySQL is a widely used, open-source relation…   9968                [OK]                
mariadb                           MariaDB is a community-developed fork of MyS…   3645                [OK]                
mysql/mysql-server                Optimized MySQL Server Docker images. Create…   727                                     [OK]
percona                           Percona Server is a fork of the MySQL relati…   509                 [OK]                
centos/mysql-57-centos7           MySQL 5.7 SQL database server                   83                                      
mysql/mysql-cluster               Experimental MySQL Cluster Docker images. Cr…   75                                      
centurylink/mysql                 Image containing mysql. Optimized to be link…   61                                      [OK]
bitnami/mysql                     Bitnami MySQL Docker Image                      44                                      [OK]
deitch/mysql-backup               REPLACED! Please use http://hub.docker.com/r…   41                                      [OK]
tutum/mysql                       Base docker image to run a MySQL database se…   35                                      
prom/mysqld-exporter                                                              31                                      [OK]
schickling/mysql-backup-s3        Backup MySQL to S3 (supports periodic backup…   30                                      [OK]
databack/mysql-backup             Back up mysql databases to... anywhere!         30                                      
linuxserver/mysql                 A Mysql container, brought to you by LinuxSe…   26                                      
centos/mysql-56-centos7           MySQL 5.6 SQL database server                   20                                      
circleci/mysql                    MySQL is a widely used, open-source relation…   19                                      
mysql/mysql-router                MySQL Router provides transparent routing be…   16                                      
arey/mysql-client                 Run a MySQL client from a docker container      14                                      [OK]
fradelg/mysql-cron-backup         MySQL/MariaDB database backup using cron tas…   8                                       [OK]
openshift/mysql-55-centos7        DEPRECATED: A Centos7 based MySQL v5.5 image…   6                                       
devilbox/mysql                    Retagged MySQL, MariaDB and PerconaDB offici…   3                                       
ansibleplaybookbundle/mysql-apb   An APB which deploys RHSCL MySQL                2                                       [OK]
widdpim/mysql-client              Dockerized MySQL Client (5.7) including Curl…   1                                       [OK]
jelastic/mysql                    An image of the MySQL database server mainta…   1                                       
monasca/mysql-init                A minimal decoupled init container for mysql    0                                       

</code></pre>
<ul>
<li><strong>直接下载最新的Mysql镜像</strong></li>
</ul>
<pre><code>docker pull mysql
</code></pre>
<ul>
<li><strong>查看Docker 镜像</strong></li>
</ul>
<pre><code>docker images
</code></pre>
<p>结果如下：</p>
<pre><code>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mysql               latest              e1d7dc9731da        7 days ago          544MB

</code></pre>
<ul>
<li><strong>在opt下创建mysql的挂载目录</strong></li>
</ul>
<pre><code>cd /opt/

mkdir mysql_docker

cd mysql_docker/

echo $PWD
</code></pre>
<ul>
<li><strong>在conf目录下新建my.cnf配置文件</strong></li>
</ul>
<pre><code>[mysqld]
#主从复制设置 本机为副本实例
server-id=2
relay-log=relay-log
relay-log-index=relay-log.index
innodb_file_per_table=ON
skip_name_resolve=ON

datadir=/var/lib/mysql
socket=/var/run/mysqld/mysqld.sock
# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0
# Settings user and group are ignored when systemd is used.
# If you need to run mysqld under a different user or group,
# customize your systemd unit file for mariadb according to the
# instructions in http://fedoraproject.org/wiki/Systemd

[mysqld_safe]
log-error=/var/log/mariadb/mariadb.log
pid-file=/var/run/mariadb/mariadb.pid

#
# include all files from the config directory
#
#!includedir /etc/my.cnf.d
</code></pre>
<ul>
<li><strong>启动mysql容器</strong></li>
</ul>
<p>可以使用$PWD代替/opt/mysql_docker路径，我直接指定路径</p>
<pre><code>docker run --name mysqlserver -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=Jay@:19951027123 -d -i -p 3306:3306 mysql:latest
</code></pre>
<pre><code>docker run --name mysqlserver -v /opt/mysql_docker/conf:/etc/mysql/conf.d -v /opt/mysql_docker/logs:/logs -v /opt/mysql_docker/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=Jay@:19951027123 -d -i -p 3306:3306 mysql:latest
</code></pre>
<p>命令备注：</p>
<pre><code>-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。

-v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。

-v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。

-v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。

-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。
</code></pre>
<p>docker查看已启动的容器</p>
<pre><code> docker ps
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img2018.cnblogs.com/blog/997646/202001/997646-20200117102003235-1426406656.png" alt="image" loading="lazy"></figure>
<ul>
<li><strong>进入mysql容器，并登陆mysql</strong></li>
</ul>
<pre><code>docker exec -it mysqlserver bash
</code></pre>
<pre><code>mysql -uroot -p
</code></pre>
<p>注意：mysqld和mysql标签对应的socket文件路径不对等的问题，需要修改my.cnf文件中的socket路径为错误提示中的。然后重启mysql可以解决</p>
<pre><code>重启命令
docker restart mysqlserver
</code></pre>
<pre><code>ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)
</code></pre>
<p>然后重新登录mysql即可</p>
<figure data-type="image" tabindex="2"><img src="https://img2018.cnblogs.com/blog/997646/202001/997646-20200117102011980-2122252374.png" alt="image" loading="lazy"></figure>
<ul>
<li><strong>开启远程访问权限</strong></li>
</ul>
<pre><code>use mysql;

select host,user from user;

ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';

flush privileges;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://img2018.cnblogs.com/blog/997646/202001/997646-20200117102022439-1012036839.png" alt="image" loading="lazy"></figure>
<ul>
<li>密码太简单，最好改个密码</li>
</ul>
<pre><code>ALTER USER 'root'@'localhost' IDENTIFIED BY 'TestBicon@123';
</code></pre>
<p>改完刷新权限，重新登录</p>
<pre><code>flush privileges;
</code></pre>
<ul>
<li>查看Dokcer日志</li>
</ul>
<pre><code>docker logs -f --tail 10 a4dac74d48f7
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://img2018.cnblogs.com/blog/997646/202001/997646-20200117102048856-1273275706.png" alt="image" loading="lazy"></figure>
<p>常用命令：</p>
<ul>
<li>关闭docker中mysql容器</li>
</ul>
<pre><code>docker stop mysqlserver
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://img2018.cnblogs.com/blog/997646/202001/997646-20200117102059917-479100535.png" alt="image" loading="lazy"></figure>
<ul>
<li>docker中mysql重启</li>
</ul>
<pre><code>docker restart mysqlserver
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://img2018.cnblogs.com/blog/997646/202001/997646-20200117102109562-1174307222.png" alt="image" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql主从复制搭建]]></title>
        <id>https://luminqiang.github.io/MD4meW1ep/</id>
        <link href="https://luminqiang.github.io/MD4meW1ep/">
        </link>
        <updated>2020-09-17T23:49:16.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h4 id="主节点">主节点：</h4>
</blockquote>
<p>在my.cnf配置文件中增加配置如下：</p>
<pre><code>[mysqld]
#主从复制配置 主实例
log-bin=mysql-bin
server-id=1
innodb-file-per-table=ON
skip_name_resolve=ON
</code></pre>
<p>设置完毕后重启mysql</p>
<pre><code>systemctl restart mysqld
</code></pre>
<p>进入mysql 查看二进制日志是否开启成功</p>
<pre><code>show global variables like '%log%';
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdn.net/20180412130457822?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWNvb3Blcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image" loading="lazy"></figure>
<p>查看主节点二进制日志列表</p>
<pre><code>show master logs;
</code></pre>
<pre><code>+------------------+-----------+-----------+
| Log_name         | File_size | Encrypted |
+------------------+-----------+-----------+
| mysql-bin.000001 |       155 | No        |
+------------------+-----------+-----------+

</code></pre>
<p>查看主节点的server id</p>
<pre><code>show global variables like '%server%';
</code></pre>
<pre><code>+---------------------------------+--------------------------------------+
| Variable_name                   | Value                                |
+---------------------------------+--------------------------------------+
| character_set_server            | utf8mb4                              |
| collation_server                | utf8mb4_0900_ai_ci                   |
| innodb_dedicated_server         | OFF                                  |
| innodb_ft_server_stopword_table |                                      |
| server_id                       | 1                                    |
| server_id_bits                  | 32                                   |
| server_uuid                     | 1633904d-6597-11ea-895a-00163e084251 |
+---------------------------------+--------------------------------------+

</code></pre>
<p>创建用于数据同步的账户</p>
<pre><code>CREATE USER 'repl'@'192.168.102.11' IDENTIFIED BY '123456';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.102.11';
FLUSH PRIVILEGES;
</code></pre>
<p>查看master状态</p>
<pre><code> show master status;
</code></pre>
<pre><code>+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000001 |      155 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
</code></pre>
<pre><code>show variables like '%log_bin%';
</code></pre>
<pre><code>+---------------------------------+--------------------------------+
| Variable_name                   | Value                          |
+---------------------------------+--------------------------------+
| log_bin                         | ON                             |
| log_bin_basename                | /var/lib/mysql/mysql-bin       |
| log_bin_index                   | /var/lib/mysql/mysql-bin.index |
| log_bin_trust_function_creators | OFF                            |
| log_bin_use_v1_row_events       | OFF                            |
| sql_log_bin                     | ON                             |
+---------------------------------+--------------------------------+

</code></pre>
<ul>
<li>如果数据库有数据持续写入的话，主库上锁表，然后备份数据库</li>
</ul>
<pre><code>flush table with read lock;
</code></pre>
<p>锁表后查看主库状态，需要记录在案，待会复制主库就是从这个位置开始的。</p>
<pre><code>mysql&gt; show master status;
+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000001 |      155 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)

</code></pre>
<blockquote>
<h4 id="从数据库配置">从数据库配置</h4>
</blockquote>
<ul>
<li>首先要设置server-id并关闭binlog功能</li>
</ul>
<pre><code>show variables like '%log_bin%';
</code></pre>
<p>log_bin 如果显示为ON,标识binlog为开启状态，需要关闭</p>
<pre><code>+---------------------------------+-----------------------------+
| Variable_name                   | Value                       |
+---------------------------------+-----------------------------+
| log_bin                         | ON                          |
| log_bin_basename                | /var/lib/mysql/binlog       |
| log_bin_index                   | /var/lib/mysql/binlog.index |
| log_bin_trust_function_creators | OFF                         |
| log_bin_use_v1_row_events       | OFF                         |
| sql_log_bin                     | ON                          |
+---------------------------------+-----------------------------+

</code></pre>
<p>关闭方法为在my.cnf的[mysqld]下添加skip-log-bin</p>
<p>8.0以下版本注释掉配置即可</p>
<pre><code>#log-bin=mysql-bin
#binlog_format=mixed
#server-id   = 1
#expire_logs_days = 10
</code></pre>
<p>由于我装的是最新版本，关闭方法不一样</p>
<pre><code>[mysqld]
skip-log-bin #8.0版本关闭binlog
</code></pre>
<p>修改配置后重启mysql，再次查询log_bin状态则为关闭状态</p>
<pre><code>mysql&gt; show variables like '%log_bin%';
+---------------------------------+-------+
| Variable_name                   | Value |
+---------------------------------+-------+
| log_bin                         | OFF   |
| log_bin_basename                |       |
| log_bin_index                   |       |
| log_bin_trust_function_creators | OFF   |
| log_bin_use_v1_row_events       | OFF   |
| sql_log_bin                     | ON    |
+---------------------------------+-------+
6 rows in set (0.02 sec)

</code></pre>
<p>然后增加从库的配置，注意从库的server-id不能和主库一样，我的主库设置为1，从库就设置2：</p>
<pre><code>[mysqld]
#主从复制设置 本机为副本实例
server-id=2
relay-log=relay-log
relay-log-index=relay-log.index
innodb_file_per_table=ON
skip_name_resolve=ON
</code></pre>
<p>编辑保存，重启数据库</p>
<p>从库配置复制参数如下（这个操作实际上就是把用户、密码以及主库的其他信息写入到从库的master.info文件去）：</p>
<pre><code>CHANGE MASTER TO
MASTER_HOST='47.99.87.3',
MASTER_PORT=3306,
MASTER_USER='luminqiang_back',
MASTER_PASSWORD='Jay@:19951027123',
MASTER_LOG_FILE='mysql-bin.000001',
MASTER_LOG_POS=155;
</code></pre>
<ul>
<li>从库上开启同步开关</li>
</ul>
<pre><code>start slave;
</code></pre>
<p>我这里出现了如下异常：</p>
<pre><code>ERROR 1872 (HY000): Slave failed to initialize relay log info structure from the repository
</code></pre>
<p>去docker查看日志，会发现原因是找不到对应的中继日志，导致启动slave报错，由于mysql.slave_relay_log_info表中保留了以前的复制信息，导致新从库启动时无法找到对应文件，需要清理掉该表中的记录</p>
<p>清理命令，执行后mysql会进行如下操作</p>
<pre><code>reset slave
</code></pre>
<p>1、删除slave_master_info ，slave_relay_log_info两个表中数据</p>
<p>2、删除所有relay log文件，并重新创建新的relay log文件；</p>
<p>3、不会改变gtid_executed 或者 gtid_purged的值</p>
<p>然后重新启动</p>
<pre><code>start slave;
</code></pre>
<p>出现如下错误需要先停止slave</p>
<pre><code>ERROR 3021 (HY000): This operation cannot be performed with a running slave io thread; run STOP SLAVE IO_THREAD FOR CHANNEL '' first.
</code></pre>
<p>测试：</p>
<ul>
<li>在从节点查找二进制日志信息，并查看mydb数据库是否复制成功</li>
</ul>
<pre><code>SHOW SLAVE STATUS\G;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20180412165806457?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWNvb3Blcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image" loading="lazy"></figure>
<p>我发现我的同步不成功，看到有一条错误信息如下：</p>
<pre><code>error connecting to master 'luminqiang_back@47.99.87.3:3306' - retry-time: 60 retries: 1 message: Authentication plugin 'caching_sha2_password' reported error: Authentication requires secure connection.
</code></pre>
<p>就是主库下用来同步的账号的验证方式问题了，主库查询下用户的验证方式：</p>
<pre><code>mysql&gt; select user,host,plugin from user;
+------------------+---------------+-----------------------+
| user             | host          | plugin                |
+------------------+---------------+-----------------------+
| lumq             | %             | mysql_native_password |
| luminqiang_back  | 47.*.48.*     | caching_sha2_password |
| mysql.infoschema | localhost     | caching_sha2_password |
| mysql.session    | localhost     | caching_sha2_password |
| mysql.sys        | localhost     | caching_sha2_password |
| root             | localhost     | mysql_native_password |
+------------------+---------------+-----------------------+

</code></pre>
<p>我用的是这个账号 luminqiang_back，验证方式为caching_sha2_password，需要改成mysql_native_password，修改命令如下：</p>
<pre><code>ALTER USER luminqiang_back@47.*.48.* IDENTIFIED WITH mysql_native_password BY '111111';
</code></pre>
<p>同步指定数据库可以在主库配置增加如下配置，然后重启mysql</p>
<pre><code>binlog-do-db=ZhiFouMovie
</code></pre>
<p>建议最好是指定数据库同步，那些mysql自带的系统库是不需要同步的</p>
<p>这时在主库增加一条记录，去从库查看就是成功的了</p>
<p>slave命令相关：</p>
<pre><code>start slave;
stop slave;
reset slave;
</code></pre>
<p>总结：参考了很多博客，有些写的很不靠谱，还是需要自己多实践，多记录</p>
<ul>
<li>https://blog.csdn.net/daicooper/article/details/79905660</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序 - 动画的使用]]></title>
        <id>https://luminqiang.github.io/XDg1UTlYB/</id>
        <link href="https://luminqiang.github.io/XDg1UTlYB/">
        </link>
        <updated>2020-09-13T11:31:28.000Z</updated>
        <content type="html"><![CDATA[<p><strong>因为是第一次在微信小程序中使用动画对象，因此记录一下，先封装了一个简单的左右滑动的动画效果，其他动画效果的定义也类似，可以传递动画详细参数进去自定义。</strong></p>
<h3 id="定义一个动画工具类-animationutiljs">定义一个动画工具类 animationUtil.js</h3>
<pre><code>var app = getApp()

//左右平缓滑动
function sliderOfRightLeft(that){
  var circleCount = 0;
  // 创建一个动画实例
  var animation = wx.createAnimation({
    duration: 2000, // 动画持续时间    
    timingFunction: 'linear' // 定义动画效果，当前是匀速
  })
  // 将该变量赋值给当前动画
  that.animationData = animation
  setInterval(function () {
    if (circleCount % 2 == 0) {
      that.animationData.translateX(30).step();
    }
    else {
      that.animationData.translateX(0).step();
    }
    that.setData({
      animationData: that.animationData.export() // 通过export()方法导出数据
    })
    circleCount++;
    if (circleCount == 1000) {
      circleCount = 0;
    }
  }, 1000)
  return that.animationData;
}

module.exports = {
  sliderOfRightLeft: sliderOfRightLeft
}
</code></pre>
<ul>
<li>自定义函数需要暴露时使用</li>
</ul>
<pre><code>module.exports = {
  sliderOfRightLeft: sliderOfRightLeft
}
</code></pre>
<ul>
<li>因为是设置一直运行的首页动画，使用circleCount变量和setInterval周期函数控制动画重复播放</li>
<li>动画设置完毕后，需要返回动画对象给调用方</li>
</ul>
<h4 id="使用如下">使用如下</h4>
<ul>
<li>先引入动画工具类</li>
</ul>
<pre><code>var animationUtil= require('../../utils/animationUtil');
</code></pre>
<ul>
<li>在page的data对象中定义动画对象变量</li>
</ul>
<pre><code>Page({
  data: {
    animationData: {}
  },
</code></pre>
<ul>
<li>在view中设置动画属性，绑定动画对象</li>
</ul>
<pre><code>&lt;view animation='{{animationData}}' class=&quot;timeicon&quot;&gt;
	&lt;image wx:if=&quot;{{isnight}}&quot; src=&quot;../../image/夜晚.png&quot; mode=&quot;scaleToFill&quot;&gt;&lt;/image&gt;
	&lt;image wx:if=&quot;{{!isnight}}&quot; src=&quot;../../image/太阳.png&quot; mode=&quot;scaleToFill&quot;&gt;&lt;/image&gt;
&lt;/view&gt;
</code></pre>
<ul>
<li>最后在onShow页面加载事件中使用动画函数，传递page对象进去</li>
</ul>
<pre><code>onShow: function () {
    animationUtil.sliderOfRightLeft(this);
  },
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式服务 Trace - 慢请求的排查思路]]></title>
        <id>https://luminqiang.github.io/8Gt-IZY36/</id>
        <link href="https://luminqiang.github.io/8Gt-IZY36/">
        </link>
        <updated>2020-09-09T12:20:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="问题场景">问题场景</h3>
<p>通过系统监控发现，某个核心服务如支付下单服务在高峰期时出现少量的慢请求，有用户向客服反馈在APP上支付下单时出现等待时间比较长的情况。由于下单服务调用了多个RPC或API服务，短时间内很难判断具体是调用链中的哪个服务出现了问题。</p>
<h3 id="解决方案">解决方案</h3>
<ol>
<li>
<p>在原来单体服务的情况下，简单方法就是打印处理流程的各个步骤的耗时情况日志，然后去日志中分析耗时情况，找到引起慢请求的那个或多个服务，进行针对性的优化。</p>
</li>
<li>
<p>但是这种方案下，如果系统请求量稍微高点，就会出现多个日志穿插打印，很难一眼分辨出哪些是来自同一个请求，这时候需要一个标记来对同一个请求下的日志进行区分，这个标记可以叫做requestId，在请求进入的时候生成，放在线程上下文中，在需要的时候可以获取这个requestId并打印至日志中。</p>
</li>
<li>
<p>现在已经可以通过日志分析出导致慢请求的具体原因了，比如，发现是下单操作时数据库查询慢导致的请求耗时增加，然后对数据库进行了优化，比如索引，这个问题最终得到解决。</p>
</li>
</ol>
<p>可是没过多久，商品相关的服务又出现了请求缓慢的问题，又通过在代码中增加日志的方式来排查问题，很快，你会发现这种排查方式麻烦耗时，每次出现问题需要临时增加日志排查，不仅需要重新发布版本，而且排查时间也比较长。</p>
<p>其实，一个接口出现响应时间慢的问题，大概率是出现在跨网络调用上，如数据库查询、依赖的第三方服务、缓存服务等，我们需要在这些外部调用的地方，统一的做耗时统计并进行上报。</p>
<h3 id="切面编程-aop">切面编程 - AOP</h3>
<p>AOP是比较适合这类场景的，在不修改源代码的情况下，对处理过程进行拦截处理，我们就可以在调用外部服务时进行耗时统计，并上报至日志。</p>
<p>切面编程分成两类：</p>
<ol>
<li>静态代理：代码编译期进行代码注入，性能影响几乎忽略不计</li>
<li>动态代理：运行期间生成代理对象，会有一些性能影响</li>
</ol>
<p>由于只是生成用于排查问题的追踪日志，应该尽量减少对接口性能的影响，推荐使用静态代理的方式。</p>
<p>需要注意的点：</p>
<ul>
<li>日志上报需要一个集中存储，如Elasticsearch，如果还是打印到服务器上的文本文件中，找日志又是一个问题。</li>
<li>如果服务的请求量很大，一次完整的请求可能会多达十几次的外部请求，假设系统的QPS是1000，那么一秒钟就会产生上万条日志，排查问题并不需要这么多的日志，需要对日志进行采样过滤，简单的方式就是使用requestId，假设采集20%的日志，那么就是requestId%10==0的请求进行打印。</li>
<li>基于尽可能减少日志打印对接口性能影响的出发点，日志需要采用异步的方式写入消息队列，也可以在程序内部实现一个队里，然后由专门的消息处理程序或者处理线程把日志消息进行上报。</li>
<li>最好是在配置中心配置有日志相关的设置，比如日志打印开关、日志采样数量等，这样就会更加灵活可控。</li>
</ul>
<p>以上的改造可以解决了日志获取困难、多个请求的日志难以区分、全量日志打印的问题，但是在分布式服务的环境下，一次完整请求下的服务调用顺序是难以区分的，比如，你知道下单接口请求了A，B，C三个服务，却不知道请求的顺序是什么（异步请求前提下）。</p>
<p>现在需要其他标识去区分所依赖外部服务的调用顺序，假设这个调用顺序用字段orderId进行标识， 那么就是requestId + orderId 这两个数据维度来记录服务之间的调用关系，也就是使用 requestId 区分单次请求，用 orderId 记录每一次依赖的外部调用。</p>
<p>比如，你的请求从用户端过来，先到达 A 服务，A 服务会分别调用 B 和 C 服务，B 服务又会调用 D 和 E 服务。</p>
<p>用户到 A 服务之后会初始化一个 traceId 为 100，spanId 为 1；</p>
<p>A 服务调用 B 服务时，traceId 不变，而 spanId 用 1.1 标识，代表上一级的 spanId 是1，这一级的调用次序是 1；</p>
<p>A 调用 C 服务时，traceId 依然不变，spanId 则变为了 1.2，代表上一级的 spanId 还是 1，而调用次序则变成了 2，以此类推。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于C#中实现单例模式]]></title>
        <id>https://luminqiang.github.io/Uf8irdE0o/</id>
        <link href="https://luminqiang.github.io/Uf8irdE0o/">
        </link>
        <updated>2020-04-26T14:25:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ihostedservice">IHostedService</h2>
<p>该接口中有两个方法：</p>
<p>StartAsync：当应用程序主机准备启动服务时触发</p>
<p>StopAsync：当应用程序主机准备停止服务时触发</p>
<pre><code>//
// 摘要:
//     /// Defines methods for objects that are managed by the host. ///
public interface IHostedService
{
    //
    // 摘要:
    //     /// Triggered when the application host is ready to start the service. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the start process has been aborted.
    Task StartAsync(CancellationToken cancellationToken);

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the shutdown process should no longer be graceful.
    Task StopAsync(CancellationToken cancellationToken);
}
</code></pre>
<h2 id="ihostapplicationlifetime">IHostApplicationLifetime</h2>
<p>该接口中包含三个属性：Host程序的启动、正在停止、已停止，一个方法StopApplication，该方法用于主动停止程序。</p>
<pre><code>//
// 摘要:
//     /// Allows consumers to be notified of application lifetime events. ///
public interface IHostApplicationLifetime
{
    //
    // 摘要:
    //     /// Triggered when the application host has fully started. ///
    CancellationToken ApplicationStarted
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopped
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopping
    {
        get;
    }

    //
    // 摘要:
    //     /// Requests termination of the current application. ///
    void StopApplication();
}
</code></pre>
<p>这里实现<strong>IHostedService</strong>接口，然后使用<strong>IHostApplicationLifetime</strong>（该接口由框架自动实现注入），在<strong>IHostedService</strong>的<strong>StartAsync</strong>方法中注册<strong>IHostApplicationLifetime</strong>中的三个程序运行事件，可以做一些自定义的操作，我这里只是记录了日志。</p>
<pre><code>internal class LifetimeEventsHostedService : IHostedService
{
    private readonly string appCode = ConfigurationManager.GetAppSetting(&quot;AppCode&quot;);
    private readonly string appName = ConfigurationManager.GetAppSetting(&quot;AppName&quot;);
    private readonly IHostApplicationLifetime _appLifetime;

    public LifetimeEventsHostedService(IHostApplicationLifetime appLifetime)
    {
        _appLifetime = appLifetime;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _appLifetime.ApplicationStarted.Register(OnStarted);
        _appLifetime.ApplicationStopping.Register(OnStopping);
        _appLifetime.ApplicationStopped.Register(OnStopped);

        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    private void OnStarted()
    {
        var interNetworkV6 = System.Net.Sockets.AddressFamily.InterNetworkV6;
        var interNetwork = System.Net.Sockets.AddressFamily.InterNetwork;
        var ipList = System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces()
          .Select(p =&gt; p.GetIPProperties())
          .SelectMany(p =&gt; p.UnicastAddresses)
          .Where(p =&gt; (p.Address.AddressFamily == interNetwork || p.Address.AddressFamily == interNetworkV6) &amp;&amp; !System.Net.IPAddress.IsLoopback(p.Address)).ToList();

        Console.WriteLine($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
        Logger.Info($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
    }

    private void OnStopping()
    {
        Console.WriteLine($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }

    private void OnStopped()
    {
        Console.WriteLine($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }
}
</code></pre>
<p><strong>最后在服务中注入</strong></p>
<pre><code>.ConfigureServices(a =&gt;
{
    a.AddSingleton&lt;IHostedService, LifetimeEventsHostedService&gt;();
});
</code></pre>
<p><strong>也可以不使用IHostedService进行承载，直接使用IHostApplicationLifetime进行注册</strong></p>
<pre><code>internal static class RegisterLifetimeEvents
    {
        private static readonly string appCode = ConfigurationManager.GetAppSetting(&quot;AppCode&quot;);
        private static readonly string appName = ConfigurationManager.GetAppSetting(&quot;AppName&quot;);
        private static readonly string iPV4Address;
        private static readonly string iPV6Address;

        static RegisterLifetimeEvents()
        {
            var interNetworkV6 = AddressFamily.InterNetworkV6;
            var interNetwork = AddressFamily.InterNetwork;
            var ipList = NetworkInterface.GetAllNetworkInterfaces()
                .Select(p =&gt; p.GetIPProperties())
                .SelectMany(p =&gt; p.UnicastAddresses)
                .Where(p =&gt; (p.Address.AddressFamily == interNetwork || p.Address.AddressFamily == interNetworkV6) &amp;&amp; !System.Net.IPAddress.IsLoopback(p.Address)).ToList();

            iPV4Address = ipList[1]?.Address.ToString();
            iPV6Address = ipList[0]?.Address.ToString();
        }

        /// &lt;summary&gt;
        /// 注册应用程序生命周期事件
        /// &lt;/summary&gt;
        public static void RegisterApplicationLifetimeEvents(this IHost host)
        {
            var hostApplicationLifetime = host.Services.GetService&lt;IHostApplicationLifetime&gt;();
            hostApplicationLifetime.ApplicationStarted.Register(OnStarted);
            hostApplicationLifetime.ApplicationStopping.Register(OnStopping);
            hostApplicationLifetime.ApplicationStopped.Register(OnStopped);
        }

        private static void OnStarted()
        {
            Console.WriteLine($&quot;OnStarted has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
            Logger.Info($&quot;OnStarted has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
        }

        private static void OnStopping()
        {
            Console.WriteLine($&quot;OnStopping has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
            Logger.Info($&quot;OnStopping has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
        }

        private static void OnStopped()
        {
            Console.WriteLine($&quot;OnStopped has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
            Logger.Info($&quot;OnStopped has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
        }
    }
</code></pre>
<p>在Main函数中注册一下即可</p>
<pre><code>public static void Main(string[] args)
{
    var host = CreateHostBuilder(args).Build();
    host.RegisterApplicationLifetimeEvents();
    host.Run();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.NET Core 3.1 下Rest API 与 GRPC 性能测试比较]]></title>
        <id>https://luminqiang.github.io/Ces3IZPF5/</id>
        <link href="https://luminqiang.github.io/Ces3IZPF5/">
        </link>
        <updated>2020-04-14T12:39:57.000Z</updated>
        <content type="html"><![CDATA[<p>首先看看GRPC的定义：</p>
<p><strong>gRPC 是一种与语言无关的高性能远程过程调用 (RPC) 框架。</strong></p>
<p>gRPC 的主要优点是：</p>
<ol>
<li>现代高性能轻量级 RPC 框架。</li>
<li>协定优先 API 开发，默认使用协议缓冲区，允许与语言无关的实现。</li>
<li>可用于多种语言的工具，以生成强类型服务器和客户端。</li>
<li>支持客户端、服务器和双向流式处理调用。</li>
<li>使用 Protobuf 二进制序列化减少对网络的使用。</li>
</ol>
<p>这些优点使 gRPC 适用于：</p>
<ol>
<li>效率至关重要的轻量级微服务。</li>
<li>需要多种语言用于开发的 Polyglot 系统。</li>
<li>需要处理流式处理请求或响应的点对点实时服务。</li>
</ol>
<p>GRPC远程过程调用的最大优点就是高性能，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。</p>
<p>测试项目GitHub地址</p>
<pre><code>https://github.com/luminqiang/RESTvsGRPC
</code></pre>
<p>先运行API项目：</p>
<pre><code>dotnet run -p RestAPI.csproj -c Release
</code></pre>
<p>再运行GRPC项目：</p>
<pre><code>dotnet run -p GrpcAPI.csproj -c Release
</code></pre>
<p>最后运行基准测试项目：</p>
<pre><code>dotnet run -p RESTvsGRPC.csproj -c Release
</code></pre>
<p>等待测试结束后，测试结果如下：</p>
<pre><code>BenchmarkDotNet=v0.12.1, OS=Windows 10.0.18362.720 (1903/May2019Update/19H1)
Intel Core i5-9600K CPU 3.70GHz (Coffee Lake), 1 CPU, 6 logical and 6 physical cores
.NET Core SDK=3.1.201
  [Host]     : .NET Core 3.1.3 (CoreCLR 4.700.20.11803, CoreFX 4.700.20.12001), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 3.1.3 (CoreCLR 4.700.20.11803, CoreFX 4.700.20.12001), X64 RyuJIT
</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>IterationCount</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>RestGetSmallPayloadAsync</td>
<td>100</td>
<td style="text-align:right">9.244 ms</td>
<td style="text-align:right">0.0597 ms</td>
<td style="text-align:right">0.0558 ms</td>
</tr>
<tr>
<td>RestGetLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">741.352 ms</td>
<td style="text-align:right">3.9088 ms</td>
<td style="text-align:right">3.6563 ms</td>
</tr>
<tr>
<td>RestPostLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">835.936 ms</td>
<td style="text-align:right">4.9780 ms</td>
<td style="text-align:right">4.4129 ms</td>
</tr>
<tr>
<td>GrpcGetSmallPayloadAsync</td>
<td>100</td>
<td style="text-align:right">12.143 ms</td>
<td style="text-align:right">0.0586 ms</td>
<td style="text-align:right">0.0548 ms</td>
</tr>
<tr>
<td>GrpcStreamLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">800.875 ms</td>
<td style="text-align:right">6.4187 ms</td>
<td style="text-align:right">6.0041 ms</td>
</tr>
<tr>
<td>GrpcGetLargePayloadAsListAsync</td>
<td>100</td>
<td style="text-align:right">130.948 ms</td>
<td style="text-align:right">1.2500 ms</td>
<td style="text-align:right">1.1692 ms</td>
</tr>
<tr>
<td>GrpcPostLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">131.427 ms</td>
<td style="text-align:right">2.6249 ms</td>
<td style="text-align:right">4.4572 ms</td>
</tr>
<tr>
<td>RestGetSmallPayloadAsync</td>
<td>200</td>
<td style="text-align:right">18.368 ms</td>
<td style="text-align:right">0.1172 ms</td>
<td style="text-align:right">0.1096 ms</td>
</tr>
<tr>
<td>RestGetLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">1,509.909 ms</td>
<td style="text-align:right">4.7070 ms</td>
<td style="text-align:right">4.4029 ms</td>
</tr>
<tr>
<td>RestPostLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">1,676.551 ms</td>
<td style="text-align:right">6.6714 ms</td>
<td style="text-align:right">5.5710 ms</td>
</tr>
<tr>
<td>GrpcGetSmallPayloadAsync</td>
<td>200</td>
<td style="text-align:right">24.336 ms</td>
<td style="text-align:right">0.1501 ms</td>
<td style="text-align:right">0.1172 ms</td>
</tr>
<tr>
<td>GrpcStreamLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">1,598.346 ms</td>
<td style="text-align:right">6.5488 ms</td>
<td style="text-align:right">5.4685 ms</td>
</tr>
<tr>
<td>GrpcGetLargePayloadAsListAsync</td>
<td>200</td>
<td style="text-align:right">263.885 ms</td>
<td style="text-align:right">2.1572 ms</td>
<td style="text-align:right">2.0178 ms</td>
</tr>
<tr>
<td>GrpcPostLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">259.290 ms</td>
<td style="text-align:right">3.4813 ms</td>
<td style="text-align:right">3.0861 ms</td>
</tr>
</tbody>
</table>
<ul>
<li>当接口返回的数据量较小时，REST 的性能要比gRPC要好，当数据量变大之后gRPC的性能优势就比较明显了。</li>
<li>.NET Core 3的 json 进行了大量的优化， 在处理消息有效负载中的小数据时会产生巨大的差异，但是实际上，对于大数据有效负载，差异就不复存在了。</li>
<li>总体来说 gRPC在这一领域仍然是赢家，在业务案例中使用哪种协议的适当策略，通常在与外部世界的外部通信（例如外部服务集成，与前端的通信）中使用REST通信，内部服务之间通信采用gRPC。</li>
</ul>
<p><strong>因此在大数据量下，同时希望保持较高性能时，应考虑使用RPC进行通信，因为通过protobuf我们可以将数据压缩编码转化为二进制格式，通常传递的数据量要小得多，而且通过http2我们可以实现异步的请求，从而大大提高了通信效率。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.NET Core 3.0 ReadyToRun编译]]></title>
        <id>https://luminqiang.github.io/I1-q0wkHh/</id>
        <link href="https://luminqiang.github.io/I1-q0wkHh/">
        </link>
        <updated>2020-04-14T12:39:26.000Z</updated>
        <content type="html"><![CDATA[<p><strong>先来总结：ReadyToRun是一种通过适当增加程序包大小，来达到更快启动速度和运行内存占用的编译方式，在 .NET Core3.0后可用。</strong></p>
<p>.NET Core 3.0 Preview6，更新了能够加速程序加载速度的ReadyToRun（R2R）格式，以及可以缩减应用程序大小的组译连结（Assembly Linking）工具IL linker。</p>
<p>.NET Core 3.0让开发者可以把 .NET Core用程序编译成为R2R格式，以缩短启动的时间，微软提到，R2R是一种AOT（Ahead-Of-Time）编译的形式，其二进制文件能够减少JIT在加载应用程序需要的工作量，藉以提高加载的效能。</p>
<h3 id="为什么r2r-格式更快">为什么R2R 格式更快？</h3>
<p>由于R2R二进制文件包含了类似JIT所产生的原生码，因此能够减少JIT的工作给予执行缓冲空间，不过也因为R2R包含了一些中介语言程序代码，虽然因此产生的程序包相对来说也比较大，是一个启动效能与包大小的取舍。</p>
<p><strong>微软给出了实验数据：</strong></p>
<ul>
<li>只包含中介语言的应用程序，档案大小为150MB，内存使用量为69.1MB，而启动时间为1.9秒</li>
<li></li>
<li>使用ReadyToRun格式的相同应用程序，虽然档案略大为156MB，但是内存使用量只有55.7MB，而且启动速度只要1.3秒。</li>
</ul>
<h3 id="关于使用限制">关于使用限制：</h3>
<p>不过目前R2R仍有许多限制，R2R现在仅支持自包含（Self-contained）应用程序，在之后的预览版才会开始支持与框架相依的应用程序。.NET Core 3.0 SDK可以设定排除特定应用程序，以免被编译成为R2R，微软提到，部分应用程序不需要优化效能，不编译成R2R反而比较省空间。</p>
<p>.NET Core 3.0开始支持R2R，但R2R并不向后支持，因此较旧的.NET Core版本无法使用，另外，开发者只能编译函式库成R2R，以作为应用程序的一部分，目前还不能作为NuGet套件交付，微软表示，这项功能要依用户回馈决定是否要支持。</p>
<ul>
<li>R2R现在也不支持跨平台编译，在Windows x64环境只能编译Windows ARM32、ARM64以及x86映象檔，而在Linux x64只能编译Linux ARM32和ARM64映像档。除了R2R的更新，微软提到，.NET Core 3.0还提供了一个特别组译连结工具IL linker，可以透过分析中介语言并删减用不到的组译语言，确保自包含应用程序仅包含实际需要的程序代码，而这能够显著的降低某些应用程序的大小，微软提到，通常小型控制台应用程序可以减少最多，因为这些工具使用较小的框架子集，可以修剪的幅度比较大。微软的实验数据显示，对于最基本helloworld应用程序，可以从原本的68MB减少到大约28MB。</li>
<li>而使用映像或是相关动态功能的应用程序或框架，组译连结工具的修剪工作通常会失败，因为IL linker不认识这类动态行为，并且无法决定在Runtime的时候需要使用的帧类型。IL linker与ReadToRun编译程序可以用在同一个应用程序，微软表示，正常情况是IL linker会让应用程序变小，但是ReadyToRun编译程序又为让应用程序变大，但是效能会大幅提升，开发者可以在各种配置中进行测试，了解这些工具选项产生的影响。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C# 根据身份证号计算是否成年]]></title>
        <id>https://luminqiang.github.io/nym_-OBjN/</id>
        <link href="https://luminqiang.github.io/nym_-OBjN/">
        </link>
        <updated>2020-04-11T04:10:40.000Z</updated>
        <content type="html"><![CDATA[<pre><code>
public static int IsAdult(string input)
{
    if (!string.IsNullOrEmpty(input) &amp;&amp; !string.IsNullOrWhiteSpace(input))
    {
        if (input.Length != 15 &amp;&amp; input.Length != 18)
        {
            return 0;
        }

        string birthday;
        if (input.Length == 18)
        {
            birthday = input.Substring(6, 4) + &quot;-&quot; + input.Substring(10, 2) + &quot;-&quot; + input.Substring(12, 2);
        }
        else
        {
            birthday = &quot;19&quot; + input.Substring(6, 2) + &quot;-&quot; + input.Substring(8, 2) + &quot;-&quot; + input.Substring(10, 2);
        }

        DateTime birthDate = DateTime.Parse(birthday);
        DateTime nowDateTime = DateTime.Now;
        int age = nowDateTime.Year - birthDate.Year;
        if (nowDateTime.Month &lt; birthDate.Month || (nowDateTime.Month == birthDate.Month &amp;&amp; nowDateTime.Day &lt; birthDate.Day))
        {
            age--;
        }

        return 18 &lt;= age ? 1 : 2;
    }
    else
    {
        return 0;
    }
}


</code></pre>
]]></content>
    </entry>
</feed>