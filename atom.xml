<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://luminqiang.github.io/</id>
    <title>卢敏强的博客</title>
    <updated>2020-09-13T11:32:42.192Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://luminqiang.github.io/"/>
    <link rel="self" href="https://luminqiang.github.io/atom.xml"/>
    <subtitle>Start With Why</subtitle>
    <logo>https://luminqiang.github.io/images/avatar.png</logo>
    <icon>https://luminqiang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 卢敏强的博客</rights>
    <entry>
        <title type="html"><![CDATA[微信小程序 - 动画的使用]]></title>
        <id>https://luminqiang.github.io/XDg1UTlYB/</id>
        <link href="https://luminqiang.github.io/XDg1UTlYB/">
        </link>
        <updated>2020-09-13T11:31:28.000Z</updated>
        <content type="html"><![CDATA[<p><strong>因为是第一次在微信小程序中使用动画对象，因此记录一下，先封装了一个简单的左右滑动的动画效果，其他动画效果的定义也类似，可以传递动画详细参数进去自定义。</strong></p>
<h3 id="定义一个动画工具类-animationutiljs">定义一个动画工具类 animationUtil.js</h3>
<pre><code>var app = getApp()

//左右平缓滑动
function sliderOfRightLeft(that){
  var circleCount = 0;
  // 创建一个动画实例
  var animation = wx.createAnimation({
    duration: 2000, // 动画持续时间    
    timingFunction: 'linear' // 定义动画效果，当前是匀速
  })
  // 将该变量赋值给当前动画
  that.animationData = animation
  setInterval(function () {
    if (circleCount % 2 == 0) {
      that.animationData.translateX(30).step();
    }
    else {
      that.animationData.translateX(0).step();
    }
    that.setData({
      animationData: that.animationData.export() // 通过export()方法导出数据
    })
    circleCount++;
    if (circleCount == 1000) {
      circleCount = 0;
    }
  }, 1000)
  return that.animationData;
}

module.exports = {
  sliderOfRightLeft: sliderOfRightLeft
}
</code></pre>
<ul>
<li>自定义函数需要暴露时使用</li>
</ul>
<pre><code>module.exports = {
  sliderOfRightLeft: sliderOfRightLeft
}
</code></pre>
<ul>
<li>因为是设置一直运行的首页动画，使用circleCount变量和setInterval周期函数控制动画重复播放</li>
<li>动画设置完毕后，需要返回动画对象给调用方</li>
</ul>
<h4 id="使用如下">使用如下</h4>
<ul>
<li>先引入动画工具类</li>
</ul>
<pre><code>var animationUtil= require('../../utils/animationUtil');
</code></pre>
<ul>
<li>在page的data对象中定义动画对象变量</li>
</ul>
<pre><code>Page({
  data: {
    animationData: {}
  },
</code></pre>
<ul>
<li>在view中设置动画属性，绑定动画对象</li>
</ul>
<pre><code>&lt;view animation='{{animationData}}' class=&quot;timeicon&quot;&gt;
	&lt;image wx:if=&quot;{{isnight}}&quot; src=&quot;../../image/夜晚.png&quot; mode=&quot;scaleToFill&quot;&gt;&lt;/image&gt;
	&lt;image wx:if=&quot;{{!isnight}}&quot; src=&quot;../../image/太阳.png&quot; mode=&quot;scaleToFill&quot;&gt;&lt;/image&gt;
&lt;/view&gt;
</code></pre>
<ul>
<li>最后在onShow页面加载事件中使用动画函数，传递page对象进去</li>
</ul>
<pre><code>onShow: function () {
    animationUtil.sliderOfRightLeft(this);
  },
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式服务 Trace - 慢请求的排查思路]]></title>
        <id>https://luminqiang.github.io/8Gt-IZY36/</id>
        <link href="https://luminqiang.github.io/8Gt-IZY36/">
        </link>
        <updated>2020-09-09T12:20:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="问题场景">问题场景</h3>
<p>通过系统监控发现，某个核心服务如支付下单服务在高峰期时出现少量的慢请求，有用户向客服反馈在APP上支付下单时出现等待时间比较长的情况。由于下单服务调用了多个RPC或API服务，短时间内很难判断具体是调用链中的哪个服务出现了问题。</p>
<h3 id="解决方案">解决方案</h3>
<ol>
<li>
<p>在原来单体服务的情况下，简单方法就是打印处理流程的各个步骤的耗时情况日志，然后去日志中分析耗时情况，找到引起慢请求的那个或多个服务，进行针对性的优化。</p>
</li>
<li>
<p>但是这种方案下，如果系统请求量稍微高点，就会出现多个日志穿插打印，很难一眼分辨出哪些是来自同一个请求，这时候需要一个标记来对同一个请求下的日志进行区分，这个标记可以叫做requestId，在请求进入的时候生成，放在线程上下文中，在需要的时候可以获取这个requestId并打印至日志中。</p>
</li>
<li>
<p>现在已经可以通过日志分析出导致慢请求的具体原因了，比如，发现是下单操作时数据库查询慢导致的请求耗时增加，然后对数据库进行了优化，比如索引，这个问题最终得到解决。</p>
</li>
</ol>
<p>可是没过多久，商品相关的服务又出现了请求缓慢的问题，又通过在代码中增加日志的方式来排查问题，很快，你会发现这种排查方式麻烦耗时，每次出现问题需要临时增加日志排查，不仅需要重新发布版本，而且排查时间也比较长。</p>
<p>其实，一个接口出现响应时间慢的问题，大概率是出现在跨网络调用上，如数据库查询、依赖的第三方服务、缓存服务等，我们需要在这些外部调用的地方，统一的做耗时统计并进行上报。</p>
<h3 id="切面编程-aop">切面编程 - AOP</h3>
<p>AOP是比较适合这类场景的，在不修改源代码的情况下，对处理过程进行拦截处理，我们就可以在调用外部服务时进行耗时统计，并上报至日志。</p>
<p>切面编程分成两类：</p>
<ol>
<li>静态代理：代码编译期进行代码注入，性能影响几乎忽略不计</li>
<li>动态代理：运行期间生成代理对象，会有一些性能影响</li>
</ol>
<p>由于只是生成用于排查问题的追踪日志，应该尽量减少对接口性能的影响，推荐使用静态代理的方式。</p>
<p>需要注意的点：</p>
<ul>
<li>日志上报需要一个集中存储，如Elasticsearch，如果还是打印到服务器上的文本文件中，找日志又是一个问题。</li>
<li>如果服务的请求量很大，一次完整的请求可能会多达十几次的外部请求，假设系统的QPS是1000，那么一秒钟就会产生上万条日志，排查问题并不需要这么多的日志，需要对日志进行采样过滤，简单的方式就是使用requestId，假设采集20%的日志，那么就是requestId%10==0的请求进行打印。</li>
<li>基于尽可能减少日志打印对接口性能影响的出发点，日志需要采用异步的方式写入消息队列，也可以在程序内部实现一个队里，然后由专门的消息处理程序或者处理线程把日志消息进行上报。</li>
<li>最好是在配置中心配置有日志相关的设置，比如日志打印开关、日志采样数量等，这样就会更加灵活可控。</li>
</ul>
<p>以上的改造可以解决了日志获取困难、多个请求的日志难以区分、全量日志打印的问题，但是在分布式服务的环境下，一次完整请求下的服务调用顺序是难以区分的，比如，你知道下单接口请求了A，B，C三个服务，却不知道请求的顺序是什么（异步请求前提下）。</p>
<p>现在需要其他标识去区分所依赖外部服务的调用顺序，假设这个调用顺序用字段orderId进行标识， 那么就是requestId + orderId 这两个数据维度来记录服务之间的调用关系，也就是使用 requestId 区分单次请求，用 orderId 记录每一次依赖的外部调用。</p>
<p>比如，你的请求从用户端过来，先到达 A 服务，A 服务会分别调用 B 和 C 服务，B 服务又会调用 D 和 E 服务。</p>
<p>用户到 A 服务之后会初始化一个 traceId 为 100，spanId 为 1；</p>
<p>A 服务调用 B 服务时，traceId 不变，而 spanId 用 1.1 标识，代表上一级的 spanId 是1，这一级的调用次序是 1；</p>
<p>A 调用 C 服务时，traceId 依然不变，spanId 则变为了 1.2，代表上一级的 spanId 还是 1，而调用次序则变成了 2，以此类推。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于C#中实现单例模式]]></title>
        <id>https://luminqiang.github.io/Uf8irdE0o/</id>
        <link href="https://luminqiang.github.io/Uf8irdE0o/">
        </link>
        <updated>2020-04-26T14:25:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ihostedservice">IHostedService</h2>
<p>该接口中有两个方法：</p>
<p>StartAsync：当应用程序主机准备启动服务时触发</p>
<p>StopAsync：当应用程序主机准备停止服务时触发</p>
<pre><code>//
// 摘要:
//     /// Defines methods for objects that are managed by the host. ///
public interface IHostedService
{
    //
    // 摘要:
    //     /// Triggered when the application host is ready to start the service. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the start process has been aborted.
    Task StartAsync(CancellationToken cancellationToken);

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the shutdown process should no longer be graceful.
    Task StopAsync(CancellationToken cancellationToken);
}
</code></pre>
<h2 id="ihostapplicationlifetime">IHostApplicationLifetime</h2>
<p>该接口中包含三个属性：Host程序的启动、正在停止、已停止，一个方法StopApplication，该方法用于主动停止程序。</p>
<pre><code>//
// 摘要:
//     /// Allows consumers to be notified of application lifetime events. ///
public interface IHostApplicationLifetime
{
    //
    // 摘要:
    //     /// Triggered when the application host has fully started. ///
    CancellationToken ApplicationStarted
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopped
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopping
    {
        get;
    }

    //
    // 摘要:
    //     /// Requests termination of the current application. ///
    void StopApplication();
}
</code></pre>
<p>这里实现<strong>IHostedService</strong>接口，然后使用<strong>IHostApplicationLifetime</strong>（该接口由框架自动实现注入），在<strong>IHostedService</strong>的<strong>StartAsync</strong>方法中注册<strong>IHostApplicationLifetime</strong>中的三个程序运行事件，可以做一些自定义的操作，我这里只是记录了日志。</p>
<pre><code>internal class LifetimeEventsHostedService : IHostedService
{
    private readonly string appCode = ConfigurationManager.GetAppSetting(&quot;AppCode&quot;);
    private readonly string appName = ConfigurationManager.GetAppSetting(&quot;AppName&quot;);
    private readonly IHostApplicationLifetime _appLifetime;

    public LifetimeEventsHostedService(IHostApplicationLifetime appLifetime)
    {
        _appLifetime = appLifetime;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _appLifetime.ApplicationStarted.Register(OnStarted);
        _appLifetime.ApplicationStopping.Register(OnStopping);
        _appLifetime.ApplicationStopped.Register(OnStopped);

        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    private void OnStarted()
    {
        var interNetworkV6 = System.Net.Sockets.AddressFamily.InterNetworkV6;
        var interNetwork = System.Net.Sockets.AddressFamily.InterNetwork;
        var ipList = System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces()
          .Select(p =&gt; p.GetIPProperties())
          .SelectMany(p =&gt; p.UnicastAddresses)
          .Where(p =&gt; (p.Address.AddressFamily == interNetwork || p.Address.AddressFamily == interNetworkV6) &amp;&amp; !System.Net.IPAddress.IsLoopback(p.Address)).ToList();

        Console.WriteLine($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
        Logger.Info($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
    }

    private void OnStopping()
    {
        Console.WriteLine($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }

    private void OnStopped()
    {
        Console.WriteLine($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }
}
</code></pre>
<p><strong>最后在服务中注入</strong></p>
<pre><code>.ConfigureServices(a =&gt;
{
    a.AddSingleton&lt;IHostedService, LifetimeEventsHostedService&gt;();
});
</code></pre>
<p><strong>也可以不使用IHostedService进行承载，直接使用IHostApplicationLifetime进行注册</strong></p>
<pre><code>internal static class RegisterLifetimeEvents
    {
        private static readonly string appCode = ConfigurationManager.GetAppSetting(&quot;AppCode&quot;);
        private static readonly string appName = ConfigurationManager.GetAppSetting(&quot;AppName&quot;);
        private static readonly string iPV4Address;
        private static readonly string iPV6Address;

        static RegisterLifetimeEvents()
        {
            var interNetworkV6 = AddressFamily.InterNetworkV6;
            var interNetwork = AddressFamily.InterNetwork;
            var ipList = NetworkInterface.GetAllNetworkInterfaces()
                .Select(p =&gt; p.GetIPProperties())
                .SelectMany(p =&gt; p.UnicastAddresses)
                .Where(p =&gt; (p.Address.AddressFamily == interNetwork || p.Address.AddressFamily == interNetworkV6) &amp;&amp; !System.Net.IPAddress.IsLoopback(p.Address)).ToList();

            iPV4Address = ipList[1]?.Address.ToString();
            iPV6Address = ipList[0]?.Address.ToString();
        }

        /// &lt;summary&gt;
        /// 注册应用程序生命周期事件
        /// &lt;/summary&gt;
        public static void RegisterApplicationLifetimeEvents(this IHost host)
        {
            var hostApplicationLifetime = host.Services.GetService&lt;IHostApplicationLifetime&gt;();
            hostApplicationLifetime.ApplicationStarted.Register(OnStarted);
            hostApplicationLifetime.ApplicationStopping.Register(OnStopping);
            hostApplicationLifetime.ApplicationStopped.Register(OnStopped);
        }

        private static void OnStarted()
        {
            Console.WriteLine($&quot;OnStarted has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
            Logger.Info($&quot;OnStarted has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
        }

        private static void OnStopping()
        {
            Console.WriteLine($&quot;OnStopping has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
            Logger.Info($&quot;OnStopping has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
        }

        private static void OnStopped()
        {
            Console.WriteLine($&quot;OnStopped has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
            Logger.Info($&quot;OnStopped has been called：{appCode} {appName} {DateTime.Now} {iPV4Address} {iPV6Address}&quot;);
        }
    }
</code></pre>
<p>在Main函数中注册一下即可</p>
<pre><code>public static void Main(string[] args)
{
    var host = CreateHostBuilder(args).Build();
    host.RegisterApplicationLifetimeEvents();
    host.Run();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.NET Core 3.1 下Rest API 与 GRPC 性能测试比较]]></title>
        <id>https://luminqiang.github.io/Ces3IZPF5/</id>
        <link href="https://luminqiang.github.io/Ces3IZPF5/">
        </link>
        <updated>2020-04-14T12:39:57.000Z</updated>
        <content type="html"><![CDATA[<p>首先看看GRPC的定义：</p>
<p><strong>gRPC 是一种与语言无关的高性能远程过程调用 (RPC) 框架。</strong></p>
<p>gRPC 的主要优点是：</p>
<ol>
<li>现代高性能轻量级 RPC 框架。</li>
<li>协定优先 API 开发，默认使用协议缓冲区，允许与语言无关的实现。</li>
<li>可用于多种语言的工具，以生成强类型服务器和客户端。</li>
<li>支持客户端、服务器和双向流式处理调用。</li>
<li>使用 Protobuf 二进制序列化减少对网络的使用。</li>
</ol>
<p>这些优点使 gRPC 适用于：</p>
<ol>
<li>效率至关重要的轻量级微服务。</li>
<li>需要多种语言用于开发的 Polyglot 系统。</li>
<li>需要处理流式处理请求或响应的点对点实时服务。</li>
</ol>
<p>GRPC远程过程调用的最大优点就是高性能，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。</p>
<p>测试项目GitHub地址</p>
<pre><code>https://github.com/luminqiang/RESTvsGRPC
</code></pre>
<p>先运行API项目：</p>
<pre><code>dotnet run -p RestAPI.csproj -c Release
</code></pre>
<p>再运行GRPC项目：</p>
<pre><code>dotnet run -p GrpcAPI.csproj -c Release
</code></pre>
<p>最后运行基准测试项目：</p>
<pre><code>dotnet run -p RESTvsGRPC.csproj -c Release
</code></pre>
<p>等待测试结束后，测试结果如下：</p>
<pre><code>BenchmarkDotNet=v0.12.1, OS=Windows 10.0.18362.720 (1903/May2019Update/19H1)
Intel Core i5-9600K CPU 3.70GHz (Coffee Lake), 1 CPU, 6 logical and 6 physical cores
.NET Core SDK=3.1.201
  [Host]     : .NET Core 3.1.3 (CoreCLR 4.700.20.11803, CoreFX 4.700.20.12001), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 3.1.3 (CoreCLR 4.700.20.11803, CoreFX 4.700.20.12001), X64 RyuJIT
</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>IterationCount</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>RestGetSmallPayloadAsync</td>
<td>100</td>
<td style="text-align:right">9.244 ms</td>
<td style="text-align:right">0.0597 ms</td>
<td style="text-align:right">0.0558 ms</td>
</tr>
<tr>
<td>RestGetLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">741.352 ms</td>
<td style="text-align:right">3.9088 ms</td>
<td style="text-align:right">3.6563 ms</td>
</tr>
<tr>
<td>RestPostLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">835.936 ms</td>
<td style="text-align:right">4.9780 ms</td>
<td style="text-align:right">4.4129 ms</td>
</tr>
<tr>
<td>GrpcGetSmallPayloadAsync</td>
<td>100</td>
<td style="text-align:right">12.143 ms</td>
<td style="text-align:right">0.0586 ms</td>
<td style="text-align:right">0.0548 ms</td>
</tr>
<tr>
<td>GrpcStreamLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">800.875 ms</td>
<td style="text-align:right">6.4187 ms</td>
<td style="text-align:right">6.0041 ms</td>
</tr>
<tr>
<td>GrpcGetLargePayloadAsListAsync</td>
<td>100</td>
<td style="text-align:right">130.948 ms</td>
<td style="text-align:right">1.2500 ms</td>
<td style="text-align:right">1.1692 ms</td>
</tr>
<tr>
<td>GrpcPostLargePayloadAsync</td>
<td>100</td>
<td style="text-align:right">131.427 ms</td>
<td style="text-align:right">2.6249 ms</td>
<td style="text-align:right">4.4572 ms</td>
</tr>
<tr>
<td>RestGetSmallPayloadAsync</td>
<td>200</td>
<td style="text-align:right">18.368 ms</td>
<td style="text-align:right">0.1172 ms</td>
<td style="text-align:right">0.1096 ms</td>
</tr>
<tr>
<td>RestGetLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">1,509.909 ms</td>
<td style="text-align:right">4.7070 ms</td>
<td style="text-align:right">4.4029 ms</td>
</tr>
<tr>
<td>RestPostLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">1,676.551 ms</td>
<td style="text-align:right">6.6714 ms</td>
<td style="text-align:right">5.5710 ms</td>
</tr>
<tr>
<td>GrpcGetSmallPayloadAsync</td>
<td>200</td>
<td style="text-align:right">24.336 ms</td>
<td style="text-align:right">0.1501 ms</td>
<td style="text-align:right">0.1172 ms</td>
</tr>
<tr>
<td>GrpcStreamLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">1,598.346 ms</td>
<td style="text-align:right">6.5488 ms</td>
<td style="text-align:right">5.4685 ms</td>
</tr>
<tr>
<td>GrpcGetLargePayloadAsListAsync</td>
<td>200</td>
<td style="text-align:right">263.885 ms</td>
<td style="text-align:right">2.1572 ms</td>
<td style="text-align:right">2.0178 ms</td>
</tr>
<tr>
<td>GrpcPostLargePayloadAsync</td>
<td>200</td>
<td style="text-align:right">259.290 ms</td>
<td style="text-align:right">3.4813 ms</td>
<td style="text-align:right">3.0861 ms</td>
</tr>
</tbody>
</table>
<ul>
<li>当接口返回的数据量较小时，REST 的性能要比gRPC要好，当数据量变大之后gRPC的性能优势就比较明显了。</li>
<li>.NET Core 3的 json 进行了大量的优化， 在处理消息有效负载中的小数据时会产生巨大的差异，但是实际上，对于大数据有效负载，差异就不复存在了。</li>
<li>总体来说 gRPC在这一领域仍然是赢家，在业务案例中使用哪种协议的适当策略，通常在与外部世界的外部通信（例如外部服务集成，与前端的通信）中使用REST通信，内部服务之间通信采用gRPC。</li>
</ul>
<p><strong>因此在大数据量下，同时希望保持较高性能时，应考虑使用RPC进行通信，因为通过protobuf我们可以将数据压缩编码转化为二进制格式，通常传递的数据量要小得多，而且通过http2我们可以实现异步的请求，从而大大提高了通信效率。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.NET Core 3.0 ReadyToRun编译]]></title>
        <id>https://luminqiang.github.io/I1-q0wkHh/</id>
        <link href="https://luminqiang.github.io/I1-q0wkHh/">
        </link>
        <updated>2020-04-14T12:39:26.000Z</updated>
        <content type="html"><![CDATA[<p><strong>先来总结：ReadyToRun是一种通过适当增加程序包大小，来达到更快启动速度和运行内存占用的编译方式，在 .NET Core3.0后可用。</strong></p>
<p>.NET Core 3.0 Preview6，更新了能够加速程序加载速度的ReadyToRun（R2R）格式，以及可以缩减应用程序大小的组译连结（Assembly Linking）工具IL linker。</p>
<p>.NET Core 3.0让开发者可以把 .NET Core用程序编译成为R2R格式，以缩短启动的时间，微软提到，R2R是一种AOT（Ahead-Of-Time）编译的形式，其二进制文件能够减少JIT在加载应用程序需要的工作量，藉以提高加载的效能。</p>
<h3 id="为什么r2r-格式更快">为什么R2R 格式更快？</h3>
<p>由于R2R二进制文件包含了类似JIT所产生的原生码，因此能够减少JIT的工作给予执行缓冲空间，不过也因为R2R包含了一些中介语言程序代码，虽然因此产生的程序包相对来说也比较大，是一个启动效能与包大小的取舍。</p>
<p><strong>微软给出了实验数据：</strong></p>
<ul>
<li>只包含中介语言的应用程序，档案大小为150MB，内存使用量为69.1MB，而启动时间为1.9秒</li>
<li></li>
<li>使用ReadyToRun格式的相同应用程序，虽然档案略大为156MB，但是内存使用量只有55.7MB，而且启动速度只要1.3秒。</li>
</ul>
<h3 id="关于使用限制">关于使用限制：</h3>
<p>不过目前R2R仍有许多限制，R2R现在仅支持自包含（Self-contained）应用程序，在之后的预览版才会开始支持与框架相依的应用程序。.NET Core 3.0 SDK可以设定排除特定应用程序，以免被编译成为R2R，微软提到，部分应用程序不需要优化效能，不编译成R2R反而比较省空间。</p>
<p>.NET Core 3.0开始支持R2R，但R2R并不向后支持，因此较旧的.NET Core版本无法使用，另外，开发者只能编译函式库成R2R，以作为应用程序的一部分，目前还不能作为NuGet套件交付，微软表示，这项功能要依用户回馈决定是否要支持。</p>
<ul>
<li>R2R现在也不支持跨平台编译，在Windows x64环境只能编译Windows ARM32、ARM64以及x86映象檔，而在Linux x64只能编译Linux ARM32和ARM64映像档。除了R2R的更新，微软提到，.NET Core 3.0还提供了一个特别组译连结工具IL linker，可以透过分析中介语言并删减用不到的组译语言，确保自包含应用程序仅包含实际需要的程序代码，而这能够显著的降低某些应用程序的大小，微软提到，通常小型控制台应用程序可以减少最多，因为这些工具使用较小的框架子集，可以修剪的幅度比较大。微软的实验数据显示，对于最基本helloworld应用程序，可以从原本的68MB减少到大约28MB。</li>
<li>而使用映像或是相关动态功能的应用程序或框架，组译连结工具的修剪工作通常会失败，因为IL linker不认识这类动态行为，并且无法决定在Runtime的时候需要使用的帧类型。IL linker与ReadToRun编译程序可以用在同一个应用程序，微软表示，正常情况是IL linker会让应用程序变小，但是ReadyToRun编译程序又为让应用程序变大，但是效能会大幅提升，开发者可以在各种配置中进行测试，了解这些工具选项产生的影响。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C# 根据身份证号计算是否成年]]></title>
        <id>https://luminqiang.github.io/nym_-OBjN/</id>
        <link href="https://luminqiang.github.io/nym_-OBjN/">
        </link>
        <updated>2020-04-11T04:10:40.000Z</updated>
        <content type="html"><![CDATA[<pre><code>
public static int IsAdult(string input)
{
    if (!string.IsNullOrEmpty(input) &amp;&amp; !string.IsNullOrWhiteSpace(input))
    {
        if (input.Length != 15 &amp;&amp; input.Length != 18)
        {
            return 0;
        }

        string birthday;
        if (input.Length == 18)
        {
            birthday = input.Substring(6, 4) + &quot;-&quot; + input.Substring(10, 2) + &quot;-&quot; + input.Substring(12, 2);
        }
        else
        {
            birthday = &quot;19&quot; + input.Substring(6, 2) + &quot;-&quot; + input.Substring(8, 2) + &quot;-&quot; + input.Substring(10, 2);
        }

        DateTime birthDate = DateTime.Parse(birthday);
        DateTime nowDateTime = DateTime.Now;
        int age = nowDateTime.Year - birthDate.Year;
        if (nowDateTime.Month &lt; birthDate.Month || (nowDateTime.Month == birthDate.Month &amp;&amp; nowDateTime.Day &lt; birthDate.Day))
        {
            age--;
        }

        return 18 &lt;= age ? 1 : 2;
    }
    else
    {
        return 0;
    }
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx配置Https证书]]></title>
        <id>https://luminqiang.github.io/G2HIIUMHo/</id>
        <link href="https://luminqiang.github.io/G2HIIUMHo/">
        </link>
        <updated>2020-04-11T02:33:33.000Z</updated>
        <content type="html"><![CDATA[<pre><code>server {
    listen       80;
	server_name  luminqiang.com;
	location / {
		root   /usr/share/nginx/html;
		index  index.html index.htm;
	}
}
server {
	
    listen                    443 ssl;			#SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。
    server_name               luminqiang.com;    #将localhost修改为您证书绑定的域名，例如：www.example.com。
    ssl_certificate           /etc/nginx/cert/www.luminqiang.com.pem;
    ssl_certificate_key       /etc/nginx/cert/www.luminqiang.com.key;
    ssl_ciphers               ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件
    ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;    #使用该协议进行配置
    ssl_prefer_server_ciphers on;
    ssl_session_timeout       5m;

    location ^~/api/{
        proxy_pass http://47.99.87.3:5000;
    }
    location / {
        root   /usr/share/nginx/html;
		index  index.html index.htm;
    }
}
</code></pre>
<p>docker run -d --name nginx -p 80:80 -p 443:443 -v /usr/local/nginx/sources/home:/usr/share/nginx/html -v /usr/local/nginx/cert:/etc/nginx/cert -v /usr/local/nginx/config/default.conf:/etc/nginx/conf.d/default.conf nginx</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.NET Core 3.0 配置允许所有域名跨域]]></title>
        <id>https://luminqiang.github.io/i_Va9uR2B/</id>
        <link href="https://luminqiang.github.io/i_Va9uR2B/">
        </link>
        <updated>2020-04-09T14:03:57.000Z</updated>
        <content type="html"><![CDATA[<p>测试配置可行</p>
<pre><code>public void ConfigureServices(IServiceCollection services)
{
    services.AddCors();
}
</code></pre>
<p>SetIsOriginAllowed方法用于判断某个域名是否在允许跨域的名单中，这里不判断直接返回True</p>
<pre><code>public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)
{
    app.UseCors(options =&gt; options.SetIsOriginAllowed(x =&gt; _ = true).AllowAnyMethod().AllowAnyHeader().AllowCredentials());
}
</code></pre>
<p><strong>SetIsOriginAllowed方法注释</strong></p>
<pre><code>//
// 摘要:
//     /// Sets the specified isOriginAllowed for the underlying policy. ///
//
// 参数:
//   isOriginAllowed:
//     The function used by the policy to evaluate if an origin is allowed.
//
// 返回结果:
//     The current policy builder.
public CorsPolicyBuilder SetIsOriginAllowed(Func&lt;string, bool&gt; isOriginAllowed)
{
    throw null;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://luminqiang.github.io//post-images/1586441071443.jfif" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.NET Core 3.0 使用 IHostApplicationLifetime 处理应用启动和停止事件]]></title>
        <id>https://luminqiang.github.io/0HNFPxdKG/</id>
        <link href="https://luminqiang.github.io/0HNFPxdKG/">
        </link>
        <updated>2020-04-09T13:23:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ihostedservice">IHostedService</h2>
<p>该接口中有两个方法：</p>
<p>StartAsync：当应用程序主机准备启动服务时触发</p>
<p>StopAsync：当应用程序主机准备停止服务时触发</p>
<pre><code>//
// 摘要:
//     /// Defines methods for objects that are managed by the host. ///
public interface IHostedService
{
    //
    // 摘要:
    //     /// Triggered when the application host is ready to start the service. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the start process has been aborted.
    Task StartAsync(CancellationToken cancellationToken);

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //
    // 参数:
    //   cancellationToken:
    //     Indicates that the shutdown process should no longer be graceful.
    Task StopAsync(CancellationToken cancellationToken);
}
</code></pre>
<h2 id="ihostapplicationlifetime">IHostApplicationLifetime</h2>
<p>该接口中包含三个属性：Host程序的启动、正在停止、已停止，一个方法StopApplication，该方法用于主动停止程序。</p>
<pre><code>//
// 摘要:
//     /// Allows consumers to be notified of application lifetime events. ///
public interface IHostApplicationLifetime
{
    //
    // 摘要:
    //     /// Triggered when the application host has fully started. ///
    CancellationToken ApplicationStarted
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopped
    {
        get;
    }

    //
    // 摘要:
    //     /// Triggered when the application host is performing a graceful shutdown. ///
    //     Shutdown will block until this event completes. ///
    CancellationToken ApplicationStopping
    {
        get;
    }

    //
    // 摘要:
    //     /// Requests termination of the current application. ///
    void StopApplication();
}
</code></pre>
<p>这里实现<strong>IHostedService</strong>接口，然后使用<strong>IHostApplicationLifetime</strong>（该接口由框架自动实现注入），在<strong>IHostedService</strong>的<strong>StartAsync</strong>方法中注册<strong>IHostApplicationLifetime</strong>中的三个程序运行事件，可以做一些自定义的操作，我这里只是记录了日志。</p>
<pre><code>internal class LifetimeEventsHostedService : IHostedService
{
    private readonly string appCode = ConfigurationManager.GetAppSetting(&quot;AppCode&quot;);
    private readonly string appName = ConfigurationManager.GetAppSetting(&quot;AppName&quot;);
    private readonly IHostApplicationLifetime _appLifetime;

    public LifetimeEventsHostedService(IHostApplicationLifetime appLifetime)
    {
        _appLifetime = appLifetime;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _appLifetime.ApplicationStarted.Register(OnStarted);
        _appLifetime.ApplicationStopping.Register(OnStopping);
        _appLifetime.ApplicationStopped.Register(OnStopped);

        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    private void OnStarted()
    {
        var interNetworkV6 = System.Net.Sockets.AddressFamily.InterNetworkV6;
        var interNetwork = System.Net.Sockets.AddressFamily.InterNetwork;
        var ipList = System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces()
          .Select(p =&gt; p.GetIPProperties())
          .SelectMany(p =&gt; p.UnicastAddresses)
          .Where(p =&gt; (p.Address.AddressFamily == interNetwork || p.Address.AddressFamily == interNetworkV6) &amp;&amp; !System.Net.IPAddress.IsLoopback(p.Address)).ToList();

        Console.WriteLine($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
        Logger.Info($&quot;OnStarted has been called：【{appCode}】【{appName}】【{DateTime.Now}】 【{ipList[1].Address}】 【{ipList[0].Address}】&quot;);
    }

    private void OnStopping()
    {
        Console.WriteLine($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopping has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }

    private void OnStopped()
    {
        Console.WriteLine($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
        Logger.Info($&quot;OnStopped has been called：【{appCode}】【{appName}】【{DateTime.Now}】&quot;);
    }
}
</code></pre>
<p><strong>最后在服务中注入</strong></p>
<pre><code>.ConfigureServices(a =&gt;
{
    a.AddSingleton&lt;IHostedService, LifetimeEventsHostedService&gt;();
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理17（数据通路）]]></title>
        <id>https://luminqiang.github.io/rhctu-ULk/</id>
        <link href="https://luminqiang.github.io/rhctu-ULk/">
        </link>
        <updated>2020-02-24T02:21:23.000Z</updated>
        <content type="html"><![CDATA[<p>CPU由指令加计算两部分组成，</p>
<p>指令：我们写的代码是怎么变成一条条机器能够理解的指令；</p>
<p>计算：也就是数据的二进制表现（定点数、浮点数），加法和乘法的实现，通过什么电路（半加器、全加器）。</p>
<p>只有把“指令”和“计算”这两部分功能连通起来，也就是建立数据通路，我们才能构成一个真正完整的 CPU。</p>
<p><strong>指令周期（Instruction Cycle）</strong></p>
<p>计算机每执行一条指令的过程，可以分解成这样几个步骤：</p>
<hr>
<ol>
<li>Fetch（取得指令），也就是从 PC 寄存器里找到对应的指令地址，根据指令地址从内存里把具体的指令，加载到指令寄存器中，然后把 PC 寄存器自增，好在未来执行下一条指令。</li>
</ol>
<hr>
<ol start="2">
<li>Decode（指令译码），也就是根据指令寄存器里面的指令，解析成要进行什么样的操作，是 R、I、J 中的哪一种指令，具体要操作哪些寄存器、数据或者内存地址。</li>
</ol>
<hr>
<ol start="3">
<li>Execute（执行指令），也就是实际运行对应的 R、I、J 这些特定的指令，进行算术逻辑操作、数据传输或者直接的地址跳转。</li>
</ol>
<hr>
<ol start="4">
<li>重复进行 1～3 的步骤。</li>
</ol>
<hr>
<p>这样的步骤，就构成了永不停歇的“Fetch - Decode - Execute”的循环，我们把这个循环称之为指令周期（Instruction Cycle）。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/18/a7/1840bead02cfbe5d8f70e2f0a7b962a7.jpg" alt="image" loading="lazy"></figure>
<p>1.指令存放于存储器中（PC寄存器、指令寄存器）</p>
<p>2.控制器从寄存器中取出指令，并对指令进行解码</p>
<p>3.运算器（算术逻辑单元ALU）负责指令的执行，如果是简单的无条件跳转，不需要计算的，则直接由运算器解决</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/bd/67/bde3548a4789ba49cab74c8c1ab02a67.jpeg" alt="image" loading="lazy"></figure>
<p>除了指令周期（Instruction Cycle），CPU中还有其他周期：</p>
<ol>
<li>机器周期（Machine Cycle）</li>
<li>CPU周期（CPU Cycle）：CPU 内部的操作速度很快，但是访问内存的速度却要慢很多。每一条指令都需要从内存里面加载而来，所以我们一般把从内存里面读取一条指令的最短时间，称为 CPU 周期。</li>
<li>时钟周期（Clock Cycle）：就是CPU的主频如3.5GHZ，一个 CPU 周期，通常会由几个时钟周期累积起来。一个 CPU 周期的时间，就是这几个 Clock Cycle 的总和。</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/1a/48/1a7d2d6cf7cb78a8f48775268f452e48.jpeg" alt="image" loading="lazy"></figure>
<p>在一个指令周期中，取出指令，至少需要一个 CPU 周期，执行指令，也至少需要一个CPU周期，复杂的指令就需要更多的CPU周期（&gt;=2）,一个指令周期包含多个CPU周期，一个CPU周期包含多个时钟周期。</p>
<p><strong>建立数据通路</strong></p>
<p>数据通路就是我们的处理器单元。它通常由两类原件组成：</p>
<ol>
<li>操作元件，也叫组合逻辑元件（Combinational Element），其实就是我们的 ALU。在前面讲 ALU 的过程中可以看到，它们的功能就是在特定的输入下，根据下面的组合电路的逻辑，生成特定的输出。</li>
<li>存储元件，也有叫状态元件（State Element）的。比如我们在计算过程中需要用到的寄存器，无论是通用寄存器还是状态寄存器，其实都是存储元件。</li>
</ol>
<p>通过数据总线的方式，把它们连接起来，就可以完成数据的存储、处理和传输了，这就是所谓的建立数据通路了。</p>
<p>此时还需要控制器作为算术逻辑单元和寄存器的中间桥梁，它的逻辑就没那么复杂了。我们可以把它看成只是机械地重复“Fetch - Decode - Execute“循环中的前两个步骤，然后把最后一个步骤，通过控制器产生的控制信号，交给 ALU 去处理。</p>
<p>但实际上控制器的电路特别复杂：</p>
<p>一方面，所有 CPU 支持的指令，都会在控制器里面，被解析成不同的输出信号。我们之前说过，现在的 Intel CPU 支持 2000 个以上的指令。这意味着，控制器输出的控制信号，至少有 2000 种不同的组合。</p>
<p>运算器里的 ALU 和各种组合逻辑电路，可以认为是一个固定功能的电路。控制器“翻译”出来的，就是不同的控制信号。这些控制信号，告诉 ALU 去做不同的计算。可以说正是控制器的存在，让我们可以“编程”来实现功能，能让我们的“存储程序型计算机”名副其实。</p>
<figure data-type="image" tabindex="4"><img src="https://static001.geekbang.org/resource/image/46/6f/46087a894b4ac182fab83ac3786cad6f.jpeg" alt="image" loading="lazy"></figure>
<pre><code>指令译码器将输入的机器码，解析成不同的操作码和操作数，然后传输给 ALU 进行计算
</code></pre>
<p><strong>CPU 所需要的硬件电路</strong></p>
<ol>
<li>
<p>自然是我们之前已经讲解过的 ALU 了，它实际就是一个没有状态的，根据输入计算输出结果的第一个电路。</p>
</li>
<li>
<p>我们需要有一个能够进行状态读写的电路元件，也就是我们的寄存器。我们需要有一个电路，能够存储到上一次的计算结果。这个计算结果并不一定要立刻拿到电路的下游去使用，但是可以在需要的时候拿出来用。常见的能够进行状态读写的电路，就有锁存器（Latch），以及我们后面要讲的 D 触发器（Data/Delay Flip-flop）的电路。</p>
</li>
<li>
<p>我们需要有一个“自动”的电路，按照固定的周期，不停地实现 PC 寄存器自增，自动地去执行“Fetch - Decode - Execute“的步骤。我们的程序执行，并不是靠人去拨动开关来执行指令的。我们希望有一个“自动”的电路，不停地去一条条执行指令。</p>
<p>我们看似写了各种复杂的高级程序进行各种函数调用、条件跳转。其实只是修改 PC 寄存器里面的地址。PC 寄存器里面的地址一修改，计算机就可以加载一条指令新指令，往下运行。实际上，PC 寄存器还有一个名字，就叫作程序计数器。顾名思义，就是随着时间变化，不断去数数。数的数字变大了，就去执行一条新指令。所以，我们需要的就是一个自动数数的电路。</p>
</li>
<li>
<p>我们需要有一个“译码”的电路。无论是对于指令进行 decode，还是对于拿到的内存地址去获取对应的数据或者指令，我们都需要通过一个电路找到对应的数据。这个对应的自然就是“译码器”的电路了。</p>
</li>
</ol>
<p>需要的 4 种基本电路，它们分别是，ALU 这样的组合逻辑电路、用来存储数据的锁存器和 D 触发器电路、用来实现 PC 寄存器的计数器电路，以及用来解码和寻址的译码器电路。</p>
<p>虽然 CPU 已经是由几十亿个晶体管组成的及其复杂的电路，但是它仍然是由这样一个个基本功能的电路组成的。只要搞清楚这些电路的运作原理，你自然也就弄明白了 CPU 的工作原理。</p>
<p><strong>为什么 CPU 还会有满载运行和 Idle 闲置的状态呢？</strong></p>
<p>CPU在空闲状态就会停止执行，具体来说就是切断时钟信号，CPU的主频就会瞬间降低为0，功耗也会瞬间降低为0。由于这个空闲状态是十分短暂的，所以在任务管理器里面也只会看到CPU频率下降，不会看到降低为0。当CPU从空闲状态中恢复时，就会接通时钟信号，这样CPU频率就会上升。所以会在任务管理器里面看到CPU的频率起伏变化。</p>
<p>同时，程序计数器一直在变化，意味着满载，如果持续不变就是idle。CPU密集型任务需要CPU大量计算的任务，这个时候CPU负载就很高，IO密集型任务，CPU一直在等待IO，就会有idle。</p>
]]></content>
    </entry>
</feed>